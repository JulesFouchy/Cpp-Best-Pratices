"use strict";(self.webpackChunkteaching_toolbox_website_generator=self.webpackChunkteaching_toolbox_website_generator||[]).push([[8769],{4137:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return d}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),f=p(t),d=o,m=f["".concat(s,".").concat(d)]||f[d]||u[d]||a;return t?r.createElement(m,i(i({ref:n},c),{},{components:t})):r.createElement(m,i({ref:n},c))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=f;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var p=2;p<a;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},9038:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return f}});var r=t(7462),o=t(3366),a=(t(7294),t(4137)),i=["components"],l={title:"Range-based for loop",benefit:4,easiness:5,level:"basic-cpp",tags:["Clean Code","C++"]},s=void 0,p={unversionedId:"lessons/range-based-for-loop",id:"lessons/range-based-for-loop",title:"Range-based for loop",description:"Brief",source:"@site/../../content/lessons/range-based-for-loop.md",sourceDirName:"lessons",slug:"/lessons/range-based-for-loop",permalink:"/Learn--Clean-Code-With-Cpp/lessons/range-based-for-loop",tags:[{label:"Clean Code",permalink:"/Learn--Clean-Code-With-Cpp/tags/clean-code"},{label:"C++",permalink:"/Learn--Clean-Code-With-Cpp/tags/c"}],version:"current",frontMatter:{title:"Range-based for loop",benefit:4,easiness:5,level:"basic-cpp",tags:["Clean Code","C++"]},sidebar:"lessons",previous:{title:"Enums",permalink:"/Learn--Clean-Code-With-Cpp/lessons/enums"},next:{title:"Lambda functions",permalink:"/Learn--Clean-Code-With-Cpp/lessons/lambda"}},c=[{value:"Brief",id:"brief",children:[],level:2}],u={toc:c};function f(e){var n=e.components,t=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"brief"},"Brief"),(0,a.kt)("p",null,"If you want to go over each element of a container ",(0,a.kt)("inlineCode",{parentName:"p"},"v")," once (which the case of most ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loops) you can write:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// If you want to modify the elements of v:\nfor (auto& x : v) {\n    // ...\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// If you don't want to modify the elements of v, and your type is costly to copy:\nfor (const auto& x : v) {\n    // ...\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// If you don't want to modify the elements of v, and your type is cheap to copy:\nfor (auto x : v) {\n    // ...\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"This helps you express your intent more clearly!")),(0,a.kt)("p",null,"It guarantees that you are not modifying the index in the body of the loop to make nasty things and change the iteration process. Having this guarantee helps people reason about your code, and this is very important!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"const std::vector v = {3, 1, 17, 8};\nfor (size_t i = 0; i < v.size(); ++i) {\n    // Long body\n    // Might do i++ somewhere\n    // This is hard to debug\n}\n")))}f.isMDXComponent=!0}}]);