[{"title":"Adding a menu","type":0,"sectionRef":"#","url":"assignment/adding-a-menu/","content":"","keywords":""},{"title":"Skeleton​","type":1,"pageTitle":"Adding a menu","url":"assignment/adding-a-menu/#skeleton","content":"Here is a skeleton to help you: int main() { bool quit = false; while (!quit) { show_the_list_of_commands(); // TODO: implement this function const auto command = get_input_from_user&lt;char&gt;(); // TODO: handle the different possible values of command with a switch // NB: don't forget to handle the case of an invalid command! } } Copy Commit "},{"title":"Bonus​","type":1,"pageTitle":"Adding a menu","url":"assignment/adding-a-menu/#bonus","content":"Something that is a little annoying is that we have to make sure we don't mess up between what we say in show_the_list_of_commands() and what we actually implement in our switch. Imagine we want to change the command for a given game: we need to change it in two places, that's bad!1 Can you think of a way to make the code more robust and easier to change? Hint You could define a Game struct that would contain the name of the game as a string and the function you need to call to start the game. Then you can associate a distinct command to each game by storing the game in a map (or an array if you only plan on using numbers: the index of the game will correspond to its command). Commit "},{"title":"Refactoring​","type":1,"pageTitle":"Adding a menu","url":"assignment/adding-a-menu/#refactoring","content":"As usual, move the code to its own file in order to clean up main.cpp. Commit We are duplicating knowledge and violating the DRY principle (see DRY: Don't repeat yourself)↩ "},{"title":"Introduction","type":0,"sectionRef":"#","url":"assignment/","content":"","keywords":""},{"title":"\"Passe-moi le code !\"​","type":1,"pageTitle":"Introduction","url":"assignment/#passe-moi-le-code-","content":"Que ce soit tes sources ou ton Wi-Fi, stp passe-moi le code ! – MC-Risson In order to evaluate you, all I need is to see some code you wrote in order for me to tell which lessons you mastered. This means that the exact project you will be working on is up to you. I will provide a suggestion of a small project with guided steps, but you can choose to work on your own project instead. The main difference will be that I won't be able to provide you with guided steps for your own projects, but this also means that you will learn a ton more by doing it! You might also be more motivated to work on something you chose and care about. "},{"title":"Submitting your work​","type":1,"pageTitle":"Introduction","url":"assignment/#submitting-your-work","content":"I will be looking at your code regularly to give you feedback and start checking the lessons that you are learning. In order for me to do so, all of you must publish your work on a public Git repository (which is good practice anyways, and will be the number one lesson I will be looking at). You can use GitHub, GitLab or whatever you are used to using. Just send me a link to the relevant repository now (or as soon as you start working on the project). Also, there are some lessons that I won't be able, from looking at your code, to tell if you have read them, like Master your IDE. So it would be nice if you kept a little ReadMe of all the lessons you have read. You can also use it for yourself: for example you can take notes of the things you learned in the lesson and really don't want to forget1, write down the points that you didn't quite get, the ones you disagree with, etc. "},{"title":"Time investment​","type":1,"pageTitle":"Introduction","url":"assignment/#time-investment","content":"In terms of invested time I won't ask you more than can fit during the class sessions, i.e. 24 hours in total this semester. This means that hopefully you won't have to work (too much) outside of class on your spare time. Please note that I will only be evaluating the quality of your code, not the state of the end product. This means that it doesn't matter if you don't have time to finish the project you set out to do! Your grade will be solely based on the lessons you successfully applied in the project. So no worries please 😎. "},{"title":"Option#1: Rolling your own project​","type":1,"pageTitle":"Introduction","url":"assignment/#option1-rolling-your-own-project","content":"I would highly encourage you to do so if you are really interested in programming. You will definitely learn a ton by doing so, and produce something that you will be proud of. If you choose to do so it might be a good idea to share your plans with me so that we can discuss them, give you some feedback or suggestions, and try to estimate the time it will take you. Note that you can still embark on a huge project if you so desire because it doesn't matter if you don't finish it for the end of the semester (see Time investment). For this project you can work in groups. Simply remember that the more you are on a project, the harder it is to coordinate and produce a cohesive codebase. But if you think that a collaboration would be beneficial, then please go ahead! I also think that it only makes sense to team up with people who have roughly the same level as you. This way you will be able to help each other out and discuss ideas on equal footing. If you are looking for someone very good to help you, you can always ask your comrades or me, but working on the same project wouldn't be beneficial I believe because you won't be advancing at the same pace and/or having the same ambitions. (I might be wrong though and we can discuss that). If you choose Option#1, you don't need to care about the other pages of the Assignment section. Just know that I strongly recommend to use this template as a starting point for your code. "},{"title":"Project ideas​","type":1,"pageTitle":"Introduction","url":"assignment/#project-ideas","content":"If you are looking for inspiration I can suggest a few ideas that I would personally love working on: A Bezier-curve editor: Check out this video to learn more about Bezier curves. Bezier curves are pretty cool; you could do an editor that renders them, allows you to draw them, implement a fill algorithm to colorize the interior, and so on. Once you can render Bezier curves you can render any SVG using a library like nanosvg.Image post-processing: Apply effects like brightness, constrast, blur, and many more on an image.Image mosaic: Recreate an image by stamping a lot of small ones together, like this one.Boids: Simulate flocks of birds and other similar behaviours, using a few simple rules. Here is a great explanation by The Coding Train.A drawing app: With a few tools: brushes, shapes, etc.A tool for generative artistsCool: I am currently working on a C++ framework called Cool where we do a lot of image-related work. If you are interested in joining the adventure, there is definitely a place for you! You could work on the camera system, the lighting, the scripting, or many other things. "},{"title":"Option#2: Following the guided project​","type":1,"pageTitle":"Introduction","url":"assignment/#option2-following-the-guided-project","content":"This option will be easier to follow and shouldn't require as much time investment. The project will consist in making a few little games: hangman, noughts and crosses, etc.. It makes sense to choose this option if you don't want to have to organize and plan a project by yourself. Here you will be able to focus entirely on the micro-level programming tasks like &quot;let's get a string from the user&quot;, &quot;let's check if this word contains this letter&quot; and so on. The other pages of this section will guide you through this project step by step. I believe it is better if you work alone on this project. (But we can discuss that if you think it will be beneficial for you to team up with someone). This is a great learning practice. See The Pragmatic Programer, Chapter 3, Section Engineering Daybooks.↩ "},{"title":"Adding tests","type":0,"sectionRef":"#","url":"assignment/adding-tests/","content":"Adding tests We will go back to our Hangman game and add a few tests. Tests are very important and a huge part of the job of every developer. To learn why tests are so great and how to write them, first read the lesson. TODO SHOW HOW TO TEST SOME SIMPLE FUNCTIONS The most interesting tests will be for the logging functions like show_word_to_guess_with_missing_letters(). How can we know what has been outputed to std::cout? It is tricky and even if there was a way, this is not the right approach! Our function show_word_to_guess_with_missing_letters() is inherently hard to test because it has side-effects! If we tweak our function and move the side-effect outside of it, it will become a pure function that is much easier to test. It will also become more general, and easier to reason about! Many good reasons to get rid of the side-effects! tip You will often find that trying to design a function to make it testable also forces you to design a better function in the first place 😉 In its previous version show_word_to_guess_with_missing_letters() had two reasons to change: if we wanted to change how the string is formated, and if we wanted to change the way we output it to the user! It didn't respect the Single Responsibility Principle! Now we will split this into two simpler chunks: std::string format_word_to_guess_with_missing_letters(const std::string&amp; word, const std::vector&lt;bool&gt;&amp; letters_guessed) { // TODO: return the string instead of outputing it to std::cout } Copy and the act of outputting to std::cout is already so simple that we can use it directly in the main code: pick_a_word_to_guess(); while (player_is_alive() &amp;&amp; !player_has_won()) { show_number_of_lives(); std::cout &lt;&lt; format_word_to_guess_with_missing_letters(word_to_guess, letters_guessed); // ... Copy It might feel silly to add tests to a code that we already know to work. And even though it kinda is, there is still a lot of benefits to writing tests afterwards: common misconception: the main goal of tests is not to prove that the code you just wrote is correct (we trust you on that, even though tests can help you writing your code), they are mainly here to make sure that whenever anyone changes the code, it remains correct! (But if you can write the tests as you write the code it is even better because they will help you write and debug your code, and you are less likely to forget to test an edge case) And since we will modify our Hangman in the next section, now is a good time to add tests to it.","keywords":""},{"title":"An AI for Hangman","type":0,"sectionRef":"#","url":"assignment/ai-for-hangman/","content":"An AI for Hangman Now we want to write a program that plays Hangman by itself. You will notice that at the moment our play_hangman() function is very opaque and you cannot easily change the way the programm receives guesses from the user. This is a small design flaw that we will fix through Dependency Injection (which is a fancy way of saying that we will add a parameter to our function): void play_hangman(std::function&lt;char()&gt; get_next_guess) { // TODO: replace get_input_from_user&lt;char&gt;() with get_next_guess() } Copy","keywords":""},{"title":"Connect 4","type":0,"sectionRef":"#","url":"assignment/connect-4/","content":"Connect 4 Try to think about simple things that you know how to do and that will move you towards the final goal. If a step is too complicated, simplify it: it might not correspond to what the final game needs, but it is still some progress done.","keywords":""},{"title":"Going further","type":0,"sectionRef":"#","url":"assignment/going-further/","content":"Going further If you finished all the tutorials and still want to keep coding, now is a good time to decide by yourself what you want to add next to your project 😁 AIs for the other games? More games? Highscores and stats for the games? It is up to you! You could also come back to the code you have already written and try to improve it. Or just read lessons until you learn something new that you could apply to the code you have. There won't be any guided steps, but you can discuss with me at any time 😁","keywords":""},{"title":"Guess the number","type":0,"sectionRef":"#","url":"assignment/guess-the-number/","content":"","keywords":""},{"title":"The building blocks​","type":1,"pageTitle":"Guess the number","url":"assignment/guess-the-number/#the-building-blocks","content":"So, what do we need to code for this game? pick a random numberget an input from the usercompare the input to the number we picked, and display a message accordinglyrepeat until the user finds the correct number We will code each of these features one by one, and we will assemble them at the end. "},{"title":"Picking a random number​","type":1,"pageTitle":"Guess the number","url":"assignment/guess-the-number/#picking-a-random-number","content":"Actually this is a bit of an annoying topic in C++, because C++ wants to be very generic and fit every use case. You can read the lesson on random number generators or just copy this function: #include &lt;random&gt; /// Returns a random int between min (included) and max (included) int rand(int min, int max) { static std::default_random_engine generator{std::random_device{}()}; std::uniform_int_distribution&lt;int&gt; distribution{min, max}; return distribution(generator); } Copy Commit "},{"title":"Getting an input from the user​","type":1,"pageTitle":"Guess the number","url":"assignment/guess-the-number/#getting-an-input-from-the-user","content":"You can use std::cin for that. I recommend to wrap that bit of code inside a function, because it will make the usage more convenient afterwards: int get_int_from_user() { // TODO ;) Use std::cin to get an int, and then return it } Copy PS: did you think of what happens when the user tries to input something that is not a number? Here is a link that can help you. (NB: now you might start to understand why we wrap this code in a function: the code is not trivial so we want to encapsulate it. You can also read Write small functions.) Commit "},{"title":"The game​","type":1,"pageTitle":"Guess the number","url":"assignment/guess-the-number/#the-game","content":"We will now finish our game by implementing the last two steps: void play_guess_the_number() { // TODO } Copy First you need to pick a random numberThen you need a loop that asks the user for a number, until they guess right. For the loop you can do something like bool finished = false; while (!finished) { // Ask for a number // If it is the correct one then set finished to true // Else give a hint to the user (&quot;Greater&quot; or &quot;Smaller&quot;) } Copy Commit "},{"title":"Refactoring​","type":1,"pageTitle":"Guess the number","url":"assignment/guess-the-number/#refactoring","content":"Now that we are done with that game we will move the code into its own file, so that main.cpp is now clean again and we can start coding our next game! tip It is a good practice to first code as you want, where you want, and get something working. You can worry about cleaning up in a second step. (Read Make it work, then make it good) Think of what needs to go in the header (.hpp), and what belongs to the source file (.cpp). Tip: try to put as little things as possible in the header, because we want to keep things private as much as possible. Your main file should now look like: #include &quot;play_guess_the_number.h&quot; int main() { play_guess_the_number(); } Copy Commit "},{"title":"Hangman","type":0,"sectionRef":"#","url":"assignment/hangman/","content":"","keywords":""},{"title":"The building blocks​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#the-building-blocks","content":"We will first write the global logic of our game, and will then implement each function one by one: pick_a_word_to_guess(); while (player_is_alive() &amp;&amp; !player_has_won()) { show_number_of_lives(); show_word_to_guess_with_missing_letters(); const auto guess = get_char_from_user(); if (word_to_guess_contains(guess)) { mark_as_guessed(guess); } else { remove_one_life(); } } if (player_has_won()) { show_congrats_message(); } else { show_defeat_message(); } Copy It should look like that in the end (even though we will probably have to modify it a bit as we write our code). "},{"title":"Picking a random word​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#picking-a-random-word","content":"You might be able to reuse what we did for the last game where we needed a random int. If you do so, you will need to move the rand() code to its own file so that it can be included both in Guess the Number and Hangman. You can use a hardcoded list of words like that: #include &lt;array&gt; const char* pick_a_random_word() { static constexpr std::array words = { &quot;code&quot;, &quot;crous&quot;, &quot;imac&quot;, &quot;opengl&quot;, }; // TODO: return a random element from the array } Copy Commit   NB: you might also need to turn rand() into a template in order to be able to use it with other types of integers like size_t and uint32_t. Commit "},{"title":"Getting an input from the user​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#getting-an-input-from-the-user","content":"The code is gonna be very similar to what we did in the last game, except that we want a char instead of an int. It might be time to generalize that code with a template! First, let's move get_int_from_user() into its own get_input_from_user.h file. Commit   Then we can turn it into a template, and rename it because it is not tied to integers anymore: /// Blocks until the user inputs something of type T in the console, and then returns it template&lt;typename T&gt; T get_input_from_user() { // TODO: replace int with T } Copy Commit "},{"title":"The state of the game​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#the-state-of-the-game","content":"Now we will ask a difficult and fondamental question! Many functions we wrote in our pseudo-code need to have access to some state. For example show_number_of_lives() needs to know the number of lives, show_word_to_guess_with_holes() needs to know the word to guess and the letters that have already been found, and so on. So, how are we gonna give our functions access to this state? tip This is a complex question and there is no one true answer, so feel free to ponder and find your own 🥰 One answer might be that we will make a class which will have all the state as member variables, and that our show_number_of_lives() will be a member function. One problem with that approach is that now show_number_of_lives() also has access to variables it doesn't need like the word to guess and the letters that have already been found. It is as if we wrote show_number_of_lives(int number_of_lives, const std::string&amp; word_to_guess, const std::vector&lt;char&gt;&amp; letters_that_have_been_found), giving three parameters to our function even though it only needs one. The solution that I suggest is that we write all of them as free functions, taking only the parameters they need. We will then have our state in a struct and only pass the required parts of our state to the different functions. (See Prefer free functions). So, what do we put in our state? Well, I guess we will see as we implement each function 😉 "},{"title":"show_number_of_lives()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#show_number_of_lives","content":"This function only needs the number of lives, so its signature will be void show_number_of_lives(int number_of_lives) { // TODO } Copy Commit "},{"title":"player_is_alive()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#player_is_alive","content":"The signature of this function will be bool player_is_alive(int number_of_lives) { // TODO } Copy Commit "},{"title":"player_has_won()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#player_has_won","content":"This one is a bit tricky; we need to decide how we are gonna store the letters that the user has guessed in order to know if they have won. We have many choices of implementation. We can trade off simplicity of the code for performance if we want to. But since the words are always gonna be small (less than 100 characters, obviously) performance should not be a concern and we are gonna aim for the simplest code possible. I think a vector of bools will work great, indicating for each letter of the word if it has been found. bool player_has_won(const std::vector&lt;bool&gt;&amp; letters_guessed) { // TODO } Copy We need to know if the vector contains at least one false. You might be tempted to use a loop, but you can also use an algorithm from the standard library and do this in one line! Go search on the Internet how you can do that 😉. NB: several algorithms can be used to achieve this result and it doesn't really matter which one you pick. Commit "},{"title":"show_word_to_guess_with_missing_letters()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#show_word_to_guess_with_missing_letters","content":"We need to output something like c _ _ e void show_word_to_guess_with_missing_letters(const std::string&amp; word, const std::vector&lt;bool&gt;&amp; letters_guessed) { // TODO } Copy Commit "},{"title":"word_contains()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#word_contains","content":"bool word_contains(char letter, std::string_view word) { // TODO } Copy (NB: there might be a one-liner solution available in the standard library! Go search for it 😉) What is string_view? It is a new type from C++17. It is a non-owning reference to either a const char* or a std::string. It has many advantages: providing the same API as std::string for const char* without having to pay the cost of constructing a std::string, working with const char* and std::string as if they were the same type, etc. Just remember that it is non-owning, like a reference: it is great for passing parameters around, but if you need to store it as a long-lasting variable you probably still need to use a std::string. (You can read std::string and std::string_view) Commit "},{"title":"mark_as_guessed()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#mark_as_guessed","content":"void mark_as_guessed(char guessed_letter, std::vector&lt;bool&gt;&amp; letters_guessed, std::string_view word_to_guess) { // TODO } Copy Again, try to use an algorithm instead of a raw loop. Commit "},{"title":"remove_one_life()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#remove_one_life","content":"void remove_one_life(int&amp; lives_count) { // TODO } Copy Commit "},{"title":"show_congrats_message()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#show_congrats_message","content":"void show_congrats_message(std::string_view word_to_guess) { // TODO } Copy Commit "},{"title":"show_defeat_message()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#show_defeat_message","content":"void show_defeat_message(std::string_view word_to_guess) { // TODO } Copy Commit "},{"title":"Assembling it all​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#assembling-it-all","content":"Now we can go back to our pseudo-code and implement it. The final code might be a bit different because we did not consider the parameters we had to pass to each function, but the structure of the code is still the same! void play_hangman() { // TODO: adapt the code below to make it work pick_a_word_to_guess(); while (player_is_alive() &amp;&amp; !player_has_won()) { show_number_of_lives(); show_word_to_guess_with_missing_letters(); const auto guess = get_char_from_user(); if (word_to_guess_contains(guess)) { mark_as_guessed(guess); } else { remove_one_life(); } } if (player_has_won()) { show_congrats_message(); } else { show_defeat_message(); } } Copy Commit "},{"title":"Refactoring​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#refactoring","content":"Now, as we did for the previous game, we will move all this code into its own file. Commit "},{"title":"Bonus​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#bonus","content":""},{"title":"Enforcing invariants with a class​","type":1,"pageTitle":"Hangman","url":"assignment/hangman/#enforcing-invariants-with-a-class","content":"You noticed that in several functions we had to assert(word_to_guess.size() == letters_guessed.size()). This is because from the point of view of the function there is no guarantee that this invariant has been enforced. But because of that we end up checking the invariant many times, which is a waste of effort and requires more code (and code duplication!). So, how can we improve this situation? Well, classes are made exactly for that reason: enforcing invariants! (See Design cohesive classes). class WordWithMissingLetters { public: WordWithMissingLetters(std::string_view word) : _word{word} , _letters_revealed(word.size(), false) // The invariant is enforced by the constructor here, and no public function of this class allows users to break the invariant, so we can guarantee that it will be preserved! {} // TODO: implement the methods required by the outside world private: std::string _word; std::vector&lt;bool&gt; _letters_revealed; }; Copy Now think about which of the functions we wrote deserve (or need) to be members of this class? TIP: try to move as few functions as possible inside the class. Only those that need access to the private details of the class must (and should) be moved in the class. Member functions are harder to write and maintain because they have to make sure that the invariants are preserved, whereas free functions using the class can rely on the fact that the invariants are already enforced by the class. (See Prefer free functions). You will also probably need to add some getters. Commit   tip Designing a good class requires time and thinking, but it can simplify the rest of your code later down the road, and make your code easier to reason about. Small classes that do their job well and enforce one or two invariants are all the rage! (See Design cohesive classes) Bonus Can you find a better name for this class? The current name is great because it is descriptive, but it is a bit long. Can you find a shorter name that is still as clear as the current one? "},{"title":"Noughts and Crosses","type":0,"sectionRef":"#","url":"assignment/noughts-and-crosses/","content":"","keywords":""},{"title":"Adding the library​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses/#adding-the-library","content":"First you will need to add the library to your project. This might be a great time to read the lessons on CMake and Git submodules. Also the examples of the library might help you getting started. (In order to find them, browse the GitHub of the library). Commit "},{"title":"First steps​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses/#first-steps","content":"In order to get familiar with the library, start by trying to do some very simple things: First create a windowThen display a square in that window Again, the library provides all the examples you will need to do that 😉 "},{"title":"Drawing a board​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses/#drawing-a-board","content":"We need a 3 by 3 board. We will make our function a little more general than that since making an n by n board is as simple as a 3 by 3. But handling a board that is not square adds a little bit of complexity, and since we don't need it for now we will only make a function that can draw square boards, with as many rows as columns. void draw_board(int size, p6::Context&amp; ctx) { // TODO } Copy  tip The map function from p6 might be useful to convert your loop indices into a position in the window. Commit "},{"title":"Detecting which cell is hovered​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses/#detecting-which-cell-is-hovered","content":"In order to click and place our noughts and crosses we first need to be able to know which cell is currently hovered by the mouse. This time I want to give you a little more room to think about the design, so I am not going to give you the signature of the function(s) you need to write. Tip n°1 What will you return from this function? Or in other words: how do you represent a cell? It is probably a good occasion to create a little struct (see Use structs to group data) My solution I chose to represent a cell with a 2D index: struct CellIndex { int x; int y; }; Copy It starts as (0, 0) in the bottom left and increases one by one. I then added functions that convert from cell_index to position in the window and vice-versa which allows we to do both my drawing and my hover detection with this CellIndex type. Tip n°2 It is possible that there is no cell under the mouse, if we are outside the board. How will you handle that? Your return type probably needs to be able to indicate the absence of a cell. Since C++17 we have std::optional that is made exactly for that purpose! Commit "},{"title":"Drawing the noughts and crosses​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses/#drawing-the-noughts-and-crosses","content":"Add two functions draw_nought and draw_cross. You are free to draw them as you want (actually they don't even need to be noughts and crosses). Commit  "},{"title":"Storing the state of the game​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses/#storing-the-state-of-the-game","content":"Now to start playing we need to be able to remember where noughts and crosses have been added to the board. Basically we need a Board object that, for any given cell, can tell us if there is a cross, a nought, or nothing on that cell. To make the syntax really nice we are gonna wrap a std::array in our own Board type and add a [] operator so that we can index into it using 2D indices: enum class Player { Noughts, Crosses, }; template&lt;int size&gt; class Board { public: std::optional&lt;Player&gt;&amp; operator[](CellIndex index) { // TODO } const std::optional&lt;Player&gt;&amp; operator[](CellIndex index) const { // TODO } private: // TODO }; Copy Then we can draw all the noughts and crosses that are stored in this board: template&lt;int size&gt; void draw_noughts_and_crosses(const Board&lt;size&gt;&amp; board, p6::Context&amp; ctx) { // TODO } Copy Commit "},{"title":"Placing noughts and crosses​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses/#placing-noughts-and-crosses","content":"Then, when the player clicks on a cell, we want to add a nought or a cross in that cell. This can be done in the mouse_pressed function of the p6 context: int main() { // ... ctx.mouse_pressed = [&amp;](p6::MouseButton event) { // TODO }; } Copy Commit "},{"title":"Previewing the placement​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses/#previewing-the-placement","content":"When the player is hovering a cell we want to show what symbol they are about to put. This helps with the readability of the game. Commit "},{"title":"Checking for the end of the game​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses/#checking-for-the-end-of-the-game","content":"We are almost done! We just have to check if one of the player has won, or if the game is over because the board is full. "},{"title":"Checking that the board is full​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses/#checking-that-the-board-is-full","content":"Commit "},{"title":"Checking that a player has won​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses/#checking-that-a-player-has-won","content":"We need to check all the rows, all the columns, and all the diagonals. How are you gonna reuse the same code for the rows, the columns and the diagonals? This is not an easy question! Tip You can use std::function. More details What differs between the rows, the columns and the diagonals is the way we index into the board. Basically we want a way to loop over any line. Well, we are gonna pass that behaviour to the function through a std::function: std::optional&lt;Player&gt; check_for_winner_on_line(const Board&lt;board_size&gt;&amp; board, std::function&lt;CellIndex(int)&gt; index_generator) { // TODO } Copy Commit "},{"title":"Refactoring​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses/#refactoring","content":"Congrats, you have finished a pretty nice game! Now all that there is left to do is to move your code into its own file and add this game to the menu. Commit "},{"title":"Setting up a project","type":0,"sectionRef":"#","url":"assignment/project-setup/","content":"","keywords":""},{"title":"Git​","type":1,"pageTitle":"Setting up a project","url":"assignment/project-setup/#git","content":"First things first, let's create a Git repo. If you are not used to using Git, read the associated lesson. I also created a repo that you will be able to use as a reference / solution as you work on the project. I will regularly link to commits that correspond to the current exercise, and you can also check out the commit history. NB: in my solution there are a lot of comments that explain why I do things in a certain way. They are not good examples of comments that you should put in your code; they are only here to help you learn C++. For example these comments shouldn't appear in actual code: static constexpr int MIN = 0; // `static constexpr` is the &quot;proper&quot; way of declaring constants known at compile time static constexpr int MAX = 100; // It is as efficient as `#define` but has the benefit of working like a normal C++ variable: it has a type, etc. Copy NB: my solutions will not always be the best, partly to keep them simple, partly to leave you room to think and improve the code I give you 😉 (and partly because I am not an omniscient programmer and there might be things that I am simply not aware of). We will come back to some of the solutions later to improve them. "},{"title":"Project template​","type":1,"pageTitle":"Setting up a project","url":"assignment/project-setup/#project-template","content":"I would recommend you use this template. It is a minimalist C++ project that uses CMake. It also sets up a few tools that will be useful to you. Read its readme to learn how to build it! (NB: I don't recommend to use the dev container for this project because we will do some graphics stuff later on). "},{"title":"Introduction","type":0,"sectionRef":"#","url":"lessons/","content":"","keywords":""},{"title":"Hi 👋​","type":1,"pageTitle":"Introduction","url":"lessons/#hi-","content":"Welcome to this class! We will only assume some beginner-level experience in programming with C++ or a similar language like C#, Java, C, Javascript, etc., and will guide you from your current level to being a solid programmer who loves coding and creates amazing software 🥳. "},{"title":"Goals​","type":1,"pageTitle":"Introduction","url":"lessons/#goals","content":"What are the properties of good code? Correctness is certainly number one. And maintainability comes second, a.k.a. how easy your code is to change while preserving its correctness. Performance comes third, since it doesn't matter how fast you are if you are going in the wrong direction 😛. GOAL In this class we will focus on writing Clean Code, a.k.a. code that is correct and maintainable. Clean code is an essential concern when you start building larger projects that are meant to last for years. Anyone should be able to pick up your code and – within a reasonable time frame – understand what it does, what its role inside the project is, and how to modify it. Clean code is both a concern at the architectural level (organisation between modules and classes) and at the granular level (organisation inside a given class or function). We will see basic coding habits that make your code more expressive, general principles that help you organize your code, a few amazing design patterns, and we will get into the habit of using meaningful names and writing documentation and tests. We will also discover the amazing tools that are available to make our job easier and way more enjoyable. NOT ALL C++ Although this class makes use of C++, most of its content will be applicable to any language and any kind of programming project. "},{"title":"How to​","type":1,"pageTitle":"Introduction","url":"lessons/#how-to","content":"I will not be giving lectures. Instead I will let you all move along with the lessons and exercises at your own pace. I will be here to answer questions, and occasionally talk to the whole class about very important things that I want to highlight. I believe this is the best way for you to learn, for practicing is when the actual learning happens. Moreover, giving lectures would imply that you are all at the same point in your learning journey and are all ready to learn the same things, which is definitely never true, not for any single group of students larger than 2. These lessons are not meant to be read one after the other. Instead look at the list of lessons and pick one (or a few) that seem interesting to you; read the lessons and then try to apply them in your exercises or projects. Once you mastered them, repeat. Note that the lessons are sorted by order of importance so it makes sense to somewhat follow the order even though this is not a strict one. "},{"title":"Evaluation​","type":1,"pageTitle":"Introduction","url":"lessons/#evaluation","content":"Check out the Progress section to see how you will be graded, and the Assignment section to see what you will have to submit. My hope is that you won't spend too much time working outside of the class if this is not something you wish to do. You will have a great visibility on your current grade as you progress in the semester and you will always have the possibility to submit extra work to improve it if you wish. "},{"title":"Give me feedback​","type":1,"pageTitle":"Introduction","url":"lessons/#give-me-feedback","content":"I tried my best to deliver a great learning experience to you. I am still a novice teacher though (and even if I were experienced, one never runs out of things to learn anyways). So your feedback is more than welcome and I will happily improve my classes with your help! To do so, feel free to reach out to me directly or raise an issue on GitHub. "},{"title":"assert","type":0,"sectionRef":"#","url":"lessons/assert/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"assert","url":"lessons/assert/#brief","content":"assert is a pretty useful debugging tool. It allows you to make sure that a function is used properly by the outside world. And you don't even pay a performance cost for it because this check is removed once you build in release mode. But this also means that once in release mode you have no guarantee that the requirements are met; this means that in some cases it is better to enforce those checks with another mechanism, such as exceptions, which will remain in release mode. "},{"title":"assert​","type":1,"pageTitle":"assert","url":"lessons/assert/#assert","content":"void serve_alcohol(Person&amp; person) { assert(person.age() &gt;= 18); // Bad, this kind of check needs to remain in release mode! Because `person` could be anyone and you don't have a guarantee that this check is done anywhere. person.drink(alcohol()); } Copy Example from the Dear ImGui library assert(g.WithinFrameScope &amp;&amp; &quot;You forgot to call ImGui::NewFrame()&quot;); // Good, this does trigger when the developer using the library does something wrong, and tells them what they did wrong. Once the error has been detected and fixed in the code, we can have the guarantee that it will never happen again even in release. // Basically since this function does not depend on user input but on usage by the programmer it is safe to use an assert. Copy "},{"title":"static_assert​","type":1,"pageTitle":"assert","url":"lessons/assert/#static_assert","content":"static_assert happens at compile time, whereas assert happens at runtime. It is used, just like assert, to make sure that a function is used properly. It is especially useful in template contexts if you require that a type has certain properties: template&lt;typename T&gt; T compute_something(T t) { static_assert(std::is_floating_point&lt;T&gt;::value, // Good, fail early rather than see the function break in unexpected ways later &quot;compute_something() only works for float and double!&quot;); // ... } Copy Example from the Cereal library // Great, Cereal does some metaprogramming magic to help you use the library correctly // and gives you clear error messages in case you do something wrong. template &lt;class T, class A&gt; struct has_member_save : std::integral_constant&lt;bool, detail::has_member_save_impl&lt;T, A&gt;::value&gt; { typedef typename detail::has_member_save_impl&lt;T, A&gt; check; static_assert( check::value || !check::not_const_type, &quot;cereal detected a non-const save. \\n &quot; &quot;save member functions must always be const&quot; ); }; Copy "},{"title":"Advanced Git features","type":0,"sectionRef":"#","url":"lessons/advanced-git-features/","content":"","keywords":""},{"title":"Amend​","type":1,"pageTitle":"Advanced Git features","url":"lessons/advanced-git-features/#amend","content":"Write a commit but don't push it, you can modify it later. It can be good to save your progress even if it doesn't compile yet and you don't want to push it. "},{"title":"Rebase​","type":1,"pageTitle":"Advanced Git features","url":"lessons/advanced-git-features/#rebase","content":"Like amend, but more powerful caution Don't amend or rebase if someone has already pulled your inital commit and starting working on top of it! It will mess up the Git history and merging will be impossible. "},{"title":"Stash​","type":1,"pageTitle":"Advanced Git features","url":"lessons/advanced-git-features/#stash","content":""},{"title":"auto","type":0,"sectionRef":"#","url":"lessons/auto/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"auto","url":"lessons/auto/#brief","content":"Sometimes the type of a variable is obvious with the context, and a type declaration would be redundant. In such cases you can use auto instead: std::unique_ptr&lt;MyClass&gt; my_ptr = std::make_unique&lt;MyClass&gt;(); // Bad: we are saying twice that we want a unique pointer to MyClass auto my_ptr = std::make_unique&lt;MyClass&gt;(); // Good: we don't repeat ourselves Copy But there is more! Sometimes, even if the type is not obvious, you don't want to hardcode it! Using auto can make refactoring easier and avoid unwanted implicit conversions. You can find this discussion in more details here at 28:23. Of course there are also good reasons not to use auto in some cases. It is up to you to make that decision. tip Optimize for the reader, not the writer! You write a piece of code once, and then it will be read many many times by many people in the years to come. So facilitating the life of the readers is way more important than facilitating that of the writer. In short: we don't care if you have to type more characters, we only care about the readability of the code. So &quot;auto saves me some typing&quot; is not a good reason, but &quot;auto is more readable&quot; is. And in the cases where auto is less readable, then don't use auto! "},{"title":"Avoid nested namespaces","type":0,"sectionRef":"#","url":"lessons/avoid-nested-namespaces/","content":"Avoid nested namespaces https://youtu.be/xu7q8dGvuwk?t=1198","keywords":""},{"title":"Avoid dead code","type":0,"sectionRef":"#","url":"lessons/avoid-dead-code/","content":"Avoid dead code Don't leave commented out blocks in your code. If for some reason you want to do so, then leave a comment at the top explaining your reason ; otherwise it is very hard for readers to know what the purpose of that code is and what to do with it : is it still relevant ? is it another option ? or is it just junk ? Example from real code from a company whose name I shall not mention: void Start() { // Utils.SetEnglishLanguage(); // SetupSavedReportsFolder(); // var commandLine = GetCommandLine(); // _commandLineArguments = new CommandLineArguments(commandLine); // // set a specific GUID for the first report // if (_commandLineArguments.ContainsKey(&quot;ReportGuid&quot;)) // BloombergUnityClient.Instance.ReportGuid = Guid.Parse(_commandLineArguments[&quot;ReportGuid&quot;]); // // set a specific address to send the report to. // if (_commandLineArguments.ContainsKey(&quot;ServerAddress&quot;)) // BloombergUnityClient.Instance.config.bloombergServerHost = _commandLineArguments[&quot;ServerAddress&quot;]; // // set a specific TCP port to send the report to. // if (_commandLineArguments.ContainsKey(&quot;ServerPort&quot;)) // BloombergUnityClient.Instance.config.bloombergServerPort = Convert.ToUInt16(_commandLineArguments[&quot;ServerPort&quot;]); // // set the Transmission mode to be use to send the report // if (_commandLineArguments.ContainsKey(&quot;TransmissionMode&quot;)) // BloombergUnityClient.Instance.config.transmissionMode = (BloombergTransmissionMode) Enum.Parse(typeof(BloombergTransmissionMode), _commandLineArguments[&quot;TransmissionMode&quot;]); // // URL to use to get temporary access to write objects (breport) // if (_commandLineArguments.ContainsKey(&quot;S3_MainAPIUrl&quot;)) // BloombergUnityClient.Instance.S3_MainAPIUrl = _commandLineArguments[&quot;S3_MainAPIUrl&quot;]; // // MyServices specific to initialize the session // if (_commandLineArguments.ContainsKey(&quot;US_ApplicationId&quot;)) // { // try // { // _myServices = new MyServices(); // _myServices?.Initialize(_commandLineArguments[&quot;US_ApplicationId&quot;], _commandLineArguments[&quot;US_Email&quot;], _commandLineArguments[&quot;US_Password&quot;]); // } // catch (Exception e) // { // Debug.LogWarning($&quot;MyServices creation failed /r/n {e}&quot;); // } // } BloombergBootstrap.Bootstrap(); Reporter.Initialize(); SetCommandLine(); SetSettings(); Application.logMessageReceivedThreaded += OnLog; } Copy","keywords":""},{"title":"Cache and Branches","type":0,"sectionRef":"#","url":"lessons/cache-and-branches/","content":"Cache and Branches https://youtu.be/EmzdmqUWq3o","keywords":""},{"title":"Code reviews","type":0,"sectionRef":"#","url":"lessons/code-reviews/","content":"Code reviews https://youtu.be/ta3S8CRN2TM?t=878","keywords":""},{"title":"Composition over Inheritance","type":0,"sectionRef":"#","url":"lessons/composition-over-inheritance/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#brief","content":"Inheritance is great, but its complex. It should therefore only be used in cases that absolutely require it and when no other simpler mechanism would be able to achieve the same job. Such simpler mechanisms include functions, function overloads, composition, function objects and templates. "},{"title":"Code reuse​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#code-reuse","content":"If you are using inheritance to reuse code, then hold your horses! There are simpler ways: Use functions to reuse logicUse composition to reuse member variables "},{"title":"What is composition?​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#what-is-composition","content":"In order to reuse member variables you can put them in a struct or class and add that struct as a member of the class that needs them. For example if many different classes need to have a Transform (a.k.a. a position, a rotation and a scale) you could have all your classes inherit from Transform, but you can also add Transform as an attribute of the classes instead: class Transform { vec3 position; vec3 rotation; vec3 scale; }; class Character { public: // functions that might use _transform if they need it private: Transform _transform; }; class Obstacle { public: // functions that might use _transform if they need it private: Transform _transform; }; Copy This gives you greater control over the API of the &quot;child&quot; classes. Because when you modify a parent class the change is necessarily reflected in all the children, which is often not desired. But often you end up needing to add something in the parent class because one specific child needs it, and by doing so you impose it on all the other children which don't necessarily need or want it. With composition you have greater control over that. And also composition naturally encourages you to write smaller classes instead of inheriting from one big mother class. "},{"title":"Polymorphism​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#polymorphism","content":"There are many ways of achieving polymorphism, and inheritance is only one of them! And there are also different kinds of polymorphism: static and dynamic. "},{"title":"Static​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#static","content":"Static polymorphism happens at compile time: it is therefore more performant, but can be used in fewer situations. Static polymorphism is achieved through templates. (And function overloads can help too): void do_something(int x) {/*...*/} void do_something(float x) {/*...*/} template&lt;typename T&gt; void complicated_function(T x) { // ... do_something(x); // This will use a different function depending on whether x is an int or a float // Our overload set has helped us doing polymorphism even though the `do_something` functions are simple and don't involve templates! // ... } Copy tip Prefer static polymorphism to dynamic polymorphism whenever possible. "},{"title":"Dynamic​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#dynamic","content":"Dynamic polymorphism allows you to change the behaviour of an object or function at runtime. This is typically the use case that people have for inheritance. But there are alternatives! std::variant and std::function. std::variant​ One thing to note is that inheritance allows anyone to subclass a type at any time. This is very generic, but also very rarely needed! Most of the time you will know in advance all the possible subtypes. For example you might by writing an abstract Camera class which has exactly two child classes: TrackballCamera and FreeflyCamera. In such cases using a std::variant will be more performant, and also express the semantic better: using Camera = std::variant&lt;TrackballCamera, FreeflyCamera&gt;; Copy Since all alternatives are known at compile time, the size of Camera is known too, which means it doesn't have to be allocated on the heap! No need for pointers, new or std::unique_ptr anymore: you can simply have a Camera my_camera on the stack and use it like any old regular variable. There are no problems with copying, no weird reference semantics, no problems at all! info One downside to std::variant is that the syntax is not as nice as it could be, and it might be simpler to use inheritance. This has to be taken into account when deciding between std::variant and inheritance, and I will not blame you if you decide to pay the performance cost of inheritance for the sole reason that it is simpler to write code with inheritance than with std::variant. (Although dealing with unique_ptr can be quite cumbersome too). But remember that in some cases std::variant will be simpler to use than inheritance (and also, as always, more performant); especially if you need your type to be copiable. std::function​ std::function is an amazing type! It is basically the strategy pattern embodied in a simple-to-use type! If you need to inject behaviour into a class or if you need to pass a function as a parameter to another function, then std::function is what you need. "},{"title":"Good use cases for inheritance​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#good-use-cases-for-inheritance","content":"You might now be left wondering when using inheritance is a good idea, if reusing code and doing polymorphism are not it. And in fact, good use cases for inheritance are rare. "},{"title":"Interfaces​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#interfaces","content":"This is probably the bigger one. It is OK to inherit1 from a purely abstract class (a.k.a. a class which has no attributes, and only pure virtual methods): class ICamera { public: virtual matrix4x4 view_matrix() const = 0; virtual matrix4x4 projection_matrix() const = 0; }; Copy This is called an interface and is very useful: it allows the client code to be decoupled from any given Camera implementation, and only depend on an interface: void render_scene(const ICamera&amp; camera); // I don't depend on a specific camera implementation // I just need any object which has a `view_matrix()` and a `projection_matrix()` method Copy "},{"title":"CRTP​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#crtp","content":"The Curiously Recurring Template Pattern (CRTP) is a pretty useful implementation trick. For example it allows you to add behaviour to a class easily: class Angle : public op::Addable&lt;Angle&gt; // Defines the operators + and += This is much simpler than implementing them yourself, and less error-prone , public op::Scalable&lt;Angle&gt; // Defines Angle * float, float * Angle, and Angle *= float { // . . . }; Copy (This example uses the op library) To learn about the CRTP, check out this blog post. "},{"title":"Going further​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#going-further","content":"Going Further Mateusz Pusz, Effective replacement of dynamic polymorphism with std::variant (30min) And even multiple inheritance works very well when used with interfaces (and needs to be used in many cases because you want your types to inherit from multiple interfaces)↩ "},{"title":"CMake","type":0,"sectionRef":"#","url":"lessons/cmake/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#brief","content":"To understand modern CMake you need to understand targets. Basically a target is an executable or a library. You will define a target for your executable and describe its source files, and then you will import the targets for each library you use, and will add those targets as a dependency of your executable. Here is an example taken from p6-examples: cmake_minimum_required(VERSION 3.8) project(p6-hello-world) add_executable(${PROJECT_NAME} # Creates a target called ${PROJECT_NAME}, a.k.a. p6-hello-world src/main.cpp # And adds its source files: main.cpp and something.cpp src/something.cpp # Note that you don't need to list the header files here (.h / .hpp) ) add_subdirectory(p6) # Includes the p6 library ; this assumes that you have a folder called p6 at the same level as this CMakeLists.txt file, and that the p6 folder contains a CMakeLists.txt file target_link_libraries(${PROJECT_NAME} PRIVATE p6::p6) # Adds the target &quot;p6::p6&quot; as a dependency of our target ${PROJECT_NAME}. Unfortunately the command is called target_link_libraries() even though it can be used for other things than just linking ; don't get confused! A better name would have been add_dependency() # The name of the target &quot;p6::p6&quot; is up to the library authors. Check out their documentation to know how they called it! # The &quot;::&quot; in the name of the library's target is not mandatory, but library authors often add it because target_link_libraries() can do many different things, and if you make a typo in the name of the target it will ignore it instead of reporting an error. It is only if you have a &quot;::&quot; in the name that target_link_libraries() will know that it can't be anything but a target and will raise an error if the name doesn't actually correspond to a target. Copy And that is all you need for a basic CMakeLists.txt! If all your libraries define a target properly then you don't need anything more to build your project. (If they don't, unfortunately you will have to do their job for them). "},{"title":"CMake tips​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#cmake-tips","content":"Now we will see a few useful things that you can do with CMake: "},{"title":"Enabling warnings​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#enabling-warnings","content":"if (MSVC) # Visual Studio for Windows target_compile_options(${PROJECT_NAME} PRIVATE /WX /W3) else() # gcc and clang target_compile_options(${PROJECT_NAME} PRIVATE -Werror -Wall -Wextra -Wpedantic -pedantic-errors) endif() Copy /WX and -Werror make your compiler treat warnings as errors, and the other flags enable a lot of useful warnings. tip Warnings are your friends. They exist to protect you from bad practices and bugs. Listen to them! A C++ code that compiles is far from guaranteed to have no bugs! (mostly because of backward compatibility with C). This is why warnings are important! "},{"title":"Setting your C++ version​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#setting-your-c-version","content":"You can ask for a specific version of C++: target_compile_features(${PROJECT_NAME} PRIVATE cxx_std_20) Copy (If you don't you will probably get C++11 by default). You can even ask for finer details with parameters like cxx_variadic_templates. This can be useful to increase the portability of your code a little bit (for example if you need C++11 plus only one little feature from C++14). Don't abuse it though because it can be very tedious to maintain! "},{"title":"Adding #define (compile definitions)​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#adding-define-compile-definitions","content":"You can #define SOMETHING from CMake. This can be useful to propagate information from CMake into your project. For example you can do cmake target_compile_definitions(${PROJECT_NAME} PRIVATE USE_THIS_FEATURE ) Copy C++ #if USE_THIS_FEATURE // Do something #else // Do something else #endif Copy A very good use case is target_compile_definitions(${PROJECT_NAME} PRIVATE $&lt;$&lt;CONFIG:Debug&gt;:DEBUG&gt; ) Copy which defines DEBUG if you are building in debug mode. (This uses a generator expression. It can be read as: &quot;If the CMake CONFIG is Debug, then return DEBUG, otherwise return nothing&quot;). You can then have debug checks in your code that are only compiled in debug mode and totally removed in release: void assert_shader_is_bound(GLint id) { #if DEBUG GLint current_id; glGetIntegerv(GL_CURRENT_PROGRAM, &amp;current_id); assert(current_id == id &amp;&amp; &quot;The shader is not bound&quot;); #endif } Copy You can also give a value to your #define (by default it gets the value 1): cmake target_compile_definitions(${PROJECT_NAME} PRIVATE WINDOW_NAME=\\&quot;Django ${CMAKE_PROJECT_VERSION}\\&quot; ) Copy C++ glfwCreateWindow(1280, 720, WINDOW_NAME, nullptr, nullptr); // Which expands to: glfwCreateWindow(1280, 720, &quot;Django 1.0&quot;, nullptr, nullptr); Copy "},{"title":"Setting the output path​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#setting-the-output-path","content":"By default your executable will end up in build with many other stuff generated by CMake. You can change that with the target property RUNTIME_OUTPUT_DIRECTORY. I personnaly like to do set_target_properties(${PROJECT_NAME} PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin/${CMAKE_BUILD_TYPE}) Copy which gives me ├── bin/ │ ├── Debug │ │ ├── myproject.exe // Built in debug mode │ │ └── ... │ └── Release │ ├── myproject.exe // Built in release mode │ └── ... ├── build/ │ ├── random cmake stuff you don't need to care about │ └── ... ├── src/ │ ├── ... │ └── ... └── CMakeLists.txt Copy "},{"title":"Copying files and folders​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#copying-files-and-folders","content":"Very often in projects you need to have files available alongside your executable ; it can be images, 3D models, shaders: anything that is not built into your binary but instead loaded at runtime. You will have those files somewhere in your sources, but when you produce an executable and send it to your friends you must not forget to send the other resource files as well! CMake can help you by automating the process of copying these files to the output folder where your executable is created.  All the files required by CoolLab.exe Here is an example of how you can ask CMake to copy your asset files and folders whenever they change (taken from Cool): #! Copies FILE to the directory where the executable of your TARGET will be created # FILE can be either an absolute or a relative path. If it is relative it will be relative to ${CMAKE_SOURCE_DIR}. # Unlike the default CMake functions this one will re-copy the file whenever it changes function(copy_file TARGET FILE) # Get the part of the file path relative to the top-level CMakeLists.txt cmake_path(RELATIVE_PATH FILE BASE_DIRECTORY ${CMAKE_SOURCE_DIR} OUTPUT_VARIABLE FILE_RELATIVE_PATH) if (NOT FILE_RELATIVE_PATH) set(FILE_RELATIVE_PATH ${FILE}) endif() # Add the copy command set(DUMMY_OUTPUT_NAME ${CMAKE_CURRENT_BINARY_DIR}/DUMMY_${FILE_RELATIVE_PATH}_${TARGET}) add_custom_command( COMMENT &quot;Copying \\&quot;${FILE_RELATIVE_PATH}\\&quot;&quot; OUTPUT ${DUMMY_OUTPUT_NAME} COMMAND ${CMAKE_COMMAND} -E make_directory ${DUMMY_OUTPUT_NAME} # Create a dummy directory that CMake will use as a timestamp reference to know if the actual file has changed, when it checks for the OUTPUT (unfortunately OUTPUT can't use a generator expression so we can't use our actual output file as the OUTPUT) COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_SOURCE_DIR}/${FILE_RELATIVE_PATH} ${OUT_DIR}/${FILE_RELATIVE_PATH} # Actual copy of the file to the destination MAIN_DEPENDENCY ${FILE} ) target_sources(${TARGET} PRIVATE ${FILE}) # Required for the custom command to be run when we build our target endfunction() #! Copies FOLDER and all its files to the directory where the executable of your TARGET will be created # FOLDER can be either an absolute or a relative path. If it is relative it will be relative to ${CMAKE_SOURCE_DIR}. # Unlike the default CMake functions this one will re-copy the files of the folder whenever they change or a file is added function(copy_folder TARGET FOLDER) file(GLOB_RECURSE FILES CONFIGURE_DEPENDS ${FOLDER}/*) foreach(FILE ${FILES}) copy_file(${TARGET} ${FILE} ${OUT_DIR}) endforeach() endfunction() Copy You can either copy these functions into your project, or use this small library (Which is the recommended way because you are guaranteed that it will be up-to-date). "},{"title":"GLOB​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#glob","content":"If you don't want to have to list all your .cpp files manually in your CMakeLists.txt you can use file(GLOB_RECURSE MY_SOURCES CONFIGURE_DEPENDS src/*) Copy It will grab the list of all .cpp files in src ant put then in MY_SOURCES. GLOB_RECURSE means that it will also find files that are in the subdirectories of src. If you only want to find the files at the first level of src you can use GLOB instead. CONFIGURE_DEPENDS means that CMake will check before every build to see if files were added or deleted, and if so it will update accordingly. Without it you would need to manually tell CMake to reconfigure each time you add or remove a file. You can then use that list of files like so: add_executable(${PROJECT_NAME} ${MY_SOURCES}) Copy warning Every CMake expert will tell you that you should never use file(GLOB) or file(GLOB_RECURSE). The reason is always the same and can be found in the official CMake documentation: We do not recommend using GLOB to collect a list of source files from your source tree. If no CMakeLists.txt file changes when a source is added or removed then the generated build system cannot know when to ask CMake to regenerate. The CONFIGURE_DEPENDS flag may not work reliably on all generators, or if a new generator is added in the future that cannot support it, projects using it will be stuck. Even if CONFIGURE_DEPENDS works reliably, there is still a cost to perform the check on every rebuild. I disagree with it though, since to me maintaining a list of my .cpp files in my CMakeLists.txt is more of a hassle than having to refresh CMake manually when I add or remove a file. (And CONFIGURE_DEPENDS makes it even less of a hassle). Now that you have the arguments from both sides, pick your poison. "},{"title":"Precompiled header​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#precompiled-header","content":"A precompiled header is pretty useful (see Precompiled Header). You can create one with CMake using target_precompile_headers. target_precompile_headers(Cool PUBLIC &lt;vector&gt; &lt;string&gt; &lt;memory&gt; &lt;functional&gt; &lt;imgui/imgui.h&gt; &lt;imgui/misc/cpp/imgui_stdlib.h&gt; &lt;Cool/Log/Log.h&gt; ) Copy "},{"title":"CMake for library authors​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#cmake-for-library-authors","content":"As a library, your CMakeLists.txt has one goal: define a target containing all the required information for people to link to your library. Users should only have to do add_subdirectory(libname) target_link_libraries(${PROJECT_NAME} PRIVATE libname) Copy This is possible because a target can store a lot of things: the sources, the include directories, the compile definitions, etc. (this information is known as requirements in the literature). When users call target_link_libraries(${PROJECT_NAME} PRIVATE libname) all this information is propagated to ${PROJECT_NAME} by CMake so that our main target will get the proper includes and so on. If you want to have a look at a real-world example of modern cmake, check out p6 (small library) or Cool (big framework). "},{"title":"add_library()​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#add_library","content":"You create your library's target with add_library(libname) Copy (it is the equivalent of add_executable(exename)) "},{"title":"Use the target_xxx() commands​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#use-the-target_xxx-commands","content":"To set requirements of your library, always use a target_xxx function. They all have alternatives without the target_ prefix, but those functions affect the global state instead of just your target, which is obviously bad! For example if your project uses libA and libB, you don't want libB to see the include directories and settings of libA! These libraries should be completely independent! They are all used like so: target_xxx(target_name PRIVATE additional_parameters ...) Copy You can also use PUBLIC or INTERFACE instead of PRIVATE (see PRIVATE | PUBLIC | INTERFACE). Here are the most important functions: target_include_directories Specifies the location of the include files. For a library I would suggest to put them in a include/libname folder and to do target_include_directories(libname PUBLIC include) so that the include files are accessed with #include &lt;libname/some_file.hpp&gt;. It can also be nice to add a libname.hpp file that includes all the other header files. It allows users to include the whole library at once with #include &lt;libname/libname.hpp&gt;.target_sources Adds source files to the target (appends to the list that was already set with add_library(libname some_file.cpp)). It can be useful for example if you only need some files in some situations: add_library(Cool src/Cool.cpp) if (USE_OPENGL) target_sources(Cool PRIVATE src/OpenGL/opengl.cpp) elseif (USE_VULKAN) target_sources(Cool PRIVATE src/Vulkan/vulkan.cpp) endif() Copy target_link_libraries To add another target as a dependency.target_compile_options We have seen it in Enabling warnings.target_compile_features We have seen it in Setting your C++ version.target_compile_definitions We have seen it in Adding #define (compile definitions).target_precompile_headers We have seen it in Precompiled header. "},{"title":"PRIVATE | PUBLIC | INTERFACE​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#private--public--interface","content":"This is the visibility of the requirements set with target_xxx(). PRIVATE: Only this target will have access to these requirements. When other targets link to this one with target_link_libraries() they will not get the private requirements. For example your warning level should always be private because you do not want to impose it on your dependents: target_compile_options(libname PRIVATE -Werror -Wall) Copy PUBLIC: This target and all of its dependents will be able to access the public requirements. For example if some include directories are used both internaly and by users to access the library, then they should be public: target_include_directories(libname PUBLIC include) Copy Also if you use some other library in your headers, then it will be visible by your users when they include your header, so you need to provide your users with the library: target_link_libraries(Cool PUBLIC glad) Copy INTERFACE: This target will not have access to these requirements but its dependents will. It is a bit peculiar but can be used for example in a header-only library: the library itself does not need to see the include directory (since there is no source files at all to build), but the dependents do: target_include_directories(my-header-only-lib INTERFACE include) Copy This can also be used if the user-facing headers are different from the private ones (e.g. if you have many headers but only want users to see a libname.hpp header that includes all the other ones): target_include_directories(libname INTERFACE include) # The include folder is only used by users and only contains libname.hpp target_include_directories(libname PRIVATE src) # All the headers that we use internally are in src (alongside the .cpp) Copy tip Try to keep things private as much as possible! Don't pollute others for no reason. "},{"title":"Add an alias containing \"::\"​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#add-an-alias-containing-","content":"add_library(p6) add_library(p6::p6 ALIAS p6) Copy People care about having a name with :: because target_link_libraries() can do many different things and if you make a typo in the name of the target it will ignore it instead of reporting an error. It is only if you have a :: in the name that target_link_libraries() will know that it can't be anything but a target and will raise an error if the name doesn't actually correspond to a target. As far as the alias name goes, people have different conventions like p6::p6, p6::core etc. Pick one that you like. "},{"title":"Going further​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#going-further","content":"Going Further Mathieu Ropert, Using Modern CMake Patterns to Enforce a Good Modular Design (1h) Henry Schreiner, Modern CMake (short online book) Stephen Kelly, Embracing Modern CMake (1h) Jason Turner, C++ Weekly - Ep 208 - The Ultimate CMake / C++ Quick Start (30min) "},{"title":"Consistency in style","type":0,"sectionRef":"#","url":"lessons/consistency-in-style/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Consistency in style","url":"lessons/consistency-in-style/#brief","content":"Be consistent with the conventions you choose (e.g. camelCase vs snake_case, prefix of member variables etc.). "},{"title":"Why bother?​","type":1,"pageTitle":"Consistency in style","url":"lessons/consistency-in-style/#why-bother","content":"When your brain gets used to a convention you will find it easier to read and understand the code. On the contrary if a project breaks its own convention all the time it can be confusing. To help you in this task you have formatting tools and static analysers which will do most of the job for you. "},{"title":"Don't be too religious​","type":1,"pageTitle":"Consistency in style","url":"lessons/consistency-in-style/#dont-be-too-religious","content":"You might think that the convention you use is the best – everyone does – but it's all about trade-offs and there is no one single right answer. A new project is a great opportunity to give another convention a shot. Don't judge conventions solely on your expectations, because we are so used to the one we use that all the other feel weird at first sight. But by trying a convention for a few weeks your view of it will change. This happened to me with snake_case; I used to think that it was weird and ugly, but now I think this is the most readable convention of them all because the words are clearly separated and it helps a lot, especially with longer names. "},{"title":"C++ casts","type":0,"sectionRef":"#","url":"lessons/cpp-casts/","content":"C++ casts 5 min","keywords":""},{"title":"Dear ImGui","type":0,"sectionRef":"#","url":"lessons/dear-imgui/","content":"Dear ImGui https://youtu.be/vWXrFetSH8w","keywords":""},{"title":"const","type":0,"sectionRef":"#","url":"lessons/const/","content":"","keywords":""},{"title":"Bonus trick​","type":1,"pageTitle":"const","url":"lessons/const/#bonus-trick","content":"You can use lambdas for const variables that are complex to initialize. "},{"title":"Bad :( (because x is not const)​","type":1,"pageTitle":"const","url":"lessons/const/#bad--because-x-is-not-const","content":"enum class MyEnum { value0, value1, value2, }; int do_something(MyEnum my_enum) { int x; switch(my_enum) { case MyEnum::value0 : x = 17; break; case MyEnum::value1 : x = 5; break; case MyEnum::value2 : x = 30; break; default: x = 0; break; } // use x return x + 2; } int main() { return do_something(MyEnum::value1); } Copy "},{"title":"Good :)​","type":1,"pageTitle":"const","url":"lessons/const/#good-","content":"enum class MyEnum { value0, value1, value2, }; int do_something(MyEnum my_enum) { const int x = [my_enum]() { switch(my_enum) { case MyEnum::value0 : return 17; case MyEnum::value1 : return 5; case MyEnum::value2 : return 30; default: return 0; } }(); // parenthesis to call the lambda function that was just declared // use x return x + 2; } int main() { return do_something(MyEnum::value1); } Copy "},{"title":"Debug vs Release","type":0,"sectionRef":"#","url":"lessons/debug-vs-release/","content":"Debug vs Release","keywords":""},{"title":"Deleted functions","type":0,"sectionRef":"#","url":"lessons/deleted-functions/","content":"Deleted functions You can delete functions to prevent them from beeing used. This is mostly used to prevent a type from being copied ; for example std::unique_ptr can't be copied because there can only be one owner of the data, unlike std::shared_ptr. It can be done with the =delete syntax: class MyClass{ //... MyClass(const MyClass&amp;) = delete; // delete the copy constructor MyClass&amp; operator=(const MyClass&amp;) = delete; // delete the copy assignment //... }; Copy","keywords":""},{"title":"Use a debugger","type":0,"sectionRef":"#","url":"lessons/debugger/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Use a debugger","url":"lessons/debugger/#brief","content":"Are you tired of printing values to the terminal to know what is going on? Is your program crashing and you don't know where or why? Well the debugger has got your back! A debugger allows you to stop the execution of your program once it reaches a specific point, called a breakpoint, or once a crash occurs. Once hit, you are able to inspect the value of all the variables (and the whole program memory). You can also see which functions were called until this point through the callstack. Finally, you will be able to advance step-by-step into the execution. "},{"title":"How to (with VSCode)​","type":1,"pageTitle":"Use a debugger","url":"lessons/debugger/#how-to-with-vscode","content":""},{"title":"Prerequisites​","type":1,"pageTitle":"Use a debugger","url":"lessons/debugger/#prerequisites","content":"You need to use ms-vscode.cpptools-extension-pack and have a C++ compiler installed on your computer. "},{"title":"Configure your debugger​","type":1,"pageTitle":"Use a debugger","url":"lessons/debugger/#configure-your-debugger","content":"If you are using the template project this is already done for you! And if you are using the ms-vscode.cmake-tools extension you don't even need this launch.json config file. Yet you might want to set this up by yourself in the future. In order to do so, simply open the &quot;Run and Debug&quot; panel and click on the &quot;Run and Debug&quot; blue button. You now have to select your debugger, first option is for Linux, second is for Windows. Press Default Configuration and it will create a launch.json file under the .vscode folder.  If you want to know the specific details, doc is here. For now you only have to set the &quot;program&quot; field with the path to your executable (so you have to build your program with F7 beforehand). In general with the CMake setup it will be under ${workspaceFolder}/build/bin/Debug/YOURPROGRAM.exe but you should check to be sure. "},{"title":"Run your debugger​","type":1,"pageTitle":"Use a debugger","url":"lessons/debugger/#run-your-debugger","content":"Simply press the play button in the &quot;Run and Debug&quot; panel. Or you can also press CTRL + F5, or the bug icon in the bottom bar:  "},{"title":"Set breakpoints​","type":1,"pageTitle":"Use a debugger","url":"lessons/debugger/#set-breakpoints","content":"You can set a breakpoint by clicking on the left of the line, right before the line number, or by pressing F9.  Then, when you run your code with the debugger the program will pause when it hits a breakpoint and the editor will jump to the breakpoint which was hit. You can even place conditional breakpoints if you right-click on the red dot and select &quot;Edit Breakpoint...&quot;. Great if you want the execution to stop only if a variable has a specific value. "},{"title":"Inspect the state of your program​","type":1,"pageTitle":"Use a debugger","url":"lessons/debugger/#inspect-the-state-of-your-program","content":"Once your program paused on a breakpoint or a crash you can see the value of all variables (by hovering over them or looking in the variables window):  You can also see all the functions that have been called previously (called the call stack) and jump to them:  Finally you can execute the program step by step with the second arrow (step over) or the third one (step into):  "},{"title":"Design cohesive classes","type":0,"sectionRef":"#","url":"lessons/design-cohesive-classes/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Design cohesive classes","url":"lessons/design-cohesive-classes/#brief","content":"First, do you need a class? What is the difference between a class and a struct?1 A class can have private members, it can have methods attached to it2, and it can use inheritance. Inheritance is kinda problematic so we are not going to consider it here (see Composition over Inheritance). We are then left with methods and with private attributes, which actually both serve the same goal: enforcing invariants. tip Classes have one goal: enforcing invariants. If you don't have any invariants, you will end up with a class that only has getters and setters that do nothing special: this is basically a struct with an uglier syntax. You could also have member functions, but if your member variables all have getters and setters then you could always replace these member functions with free functions, which is a better practice anyways (see Prefer free functions). tip Prefer using a struct over a class if you have no invariants to enforce (see the C++ Core Guidelines). "},{"title":"Keep it small​","type":1,"pageTitle":"Design cohesive classes","url":"lessons/design-cohesive-classes/#keep-it-small","content":"Try not to mix concerns inside a single class: it should have only one reason to change. This is known as the Single Responsibility Principle. A good indicator: if none of your methods need to have access to all members at once then you can probably split that class into two or more smaller classes. "},{"title":"No private methods​","type":1,"pageTitle":"Design cohesive classes","url":"lessons/design-cohesive-classes/#no-private-methods","content":"Private methods are problematic because they can't be tested and they can't be reused outside of the class. Think about it: what is their advantage over a free function? Apart from the fact that they have access to all the members of the class, and therefore they don't need to declare parameters (which is a bad reason, don't be lazy!) I can't think of anything else3. So my guideline will be: don't use private member functions, use free functions that take as parameters the things they need. "},{"title":"No public methods that only use the public API​","type":1,"pageTitle":"Design cohesive classes","url":"lessons/design-cohesive-classes/#no-public-methods-that-only-use-the-public-api","content":"If your method only uses public members of the class, then it could be written as a free function: this will make your class simpler, and the overall design more decoupled. See Prefer free functions. tip Public methods are meant to access private members: this is where the encapsulation happens! If they only need public members then you can turn them into free functions. "},{"title":"Going further​","type":1,"pageTitle":"Design cohesive classes","url":"lessons/design-cohesive-classes/#going-further","content":"Going Further Tony Van Eerd, SOLID, Revisited (1h30) I am talking about the semantic differences here, because in C++ a class and a struct can do exactly the same things. The only difference is that by default if you don't use an access specifier everything is private in a class and public in a struct.↩Although I am not opposed to having methods in a struct.↩Actually they might be used in inheritance hierarchies. But since inheritance hierarchies are a bad practice too, this doesn't quite count 😛↩ "},{"title":"Dependencies","type":0,"sectionRef":"#","url":"lessons/dependencies/","content":"","keywords":""},{"title":"The Singleton attempt​","type":1,"pageTitle":"Dependencies","url":"lessons/dependencies/#the-singleton-attempt","content":"One tempting solution is to resort to the Singleton (anti-)pattern. In its simplest form it consists in making your class static 1 so that anyone can access it from anywhere. It has the advantage that you don't need to pass an instance around (which would probably require you to modify the signature of quite a few fonctions to pass the instance to the parts that need it). This makes the Singleton a really good solution in the short term. But the Singleton can end up causing a few problems, hence why most people have stopped using it : It prevents you from having multiple instances of the same class. Obviously you are a reasonable person and you use a Singleton only for classes that you need one single instance of. . . But you might realize later that actually you need to have multiple instancies. I have a few examples from my personal experience : an history seems like it is unique across the application, until you realize that having separate histories for separate systems is a useful feature. And the argument to rule them all : what if you want to have multiple instances of your application in parallel ? Then you can't have any static data because it would be shared accross the instancies of your application. For example think of a workspace in a drawing application : you might want to have multiple drawings open at once, each with it's own layer system, history, etc.It reduces testability : each class that depends on a static class cannot be used outside of the application. This is a big problem for testing (and also for reusing your code !). When testing we usually like to create fake instancies of the dependencies of a class to test that class. For example if you depend on a server, it is nice to make your tests with a mock server (for example that returns a dummy answer when you make a request, whithout even making a web call to a service) rather that the production one ! It prevents breaking things or even relying on having a server running. Also you can test different scenarios – like the server beeing down – whithout having to shut down your actual server ! This is also why you should depend on interfaces and never on concrete classes. If you depend on an IServer you can then have different test implementations : MockServerRunning, MockServerDown, MockServerLaggy etc.It hides dependencies. Even though it is a pain to write each dependency explicitly in the signature of functions, later down the road you will be happy to be able to see at a glance what is required for a given function (when refactoring for example). It will also be easier to reuse the code later in other projects if the only dependencies are at the function boundary (aka in the signature). "},{"title":"The best practices​","type":1,"pageTitle":"Dependencies","url":"lessons/dependencies/#the-best-practices","content":""},{"title":"Dependency Injection​","type":1,"pageTitle":"Dependencies","url":"lessons/dependencies/#dependency-injection","content":"Yes, you should receive as parameters all the classes / systems that you depend on. Storing them as members isn't the cleanest either in my opinion (this can be qualified though) ; I would tend to only store a reference to a class if there is a very strong coupling between the two (like a CameraController and the corresponding Camera) (EDIT : I would almost never store references because it makes copying and assigning pretty troublesome / impossible). You should always send references as parameters to each function that needs them : it prevents you from introducing extra member variables, and makes it clearer which parts of your class actually need or act upon a dependency. If you end up with too many arguments, maybe grouping them in a struct can be a good idea. This should be considered carefully though because it can lead to introducing unnecessary dependencies (if a class X needs 4 out of the 5 classes packaged in a struct Y, it can be tempting to make X depend on Y, although it will grab one unnecessary dependency, which is bad). https://youtu.be/qkGxy4c64Jg About storing a reference to a dependency​ Storing a reference is a problem because it makes your type more complex than it needs to be. I realized that after a 1 hour debugging session filled with cryptic template error messages. Having a reference in your type will make it non-copy-assignable ! That is because when trying to assign to a refence, you are actually assigning to the object behind the reference ! You cannot modify where the reference points to after its creation ! Let's have an example : class MyClass { public: // Constructor MyClass(const MyDependency&amp; my_dependency) : _my_dependency{my_dependency} // OK : initializes the reference to point to my_dependency {} // Copy Constructor MyClass(const MyClass&amp; o) : _my_dependency{o._my_dependency} // OK : initializes the reference to point to o.my_dependency {} // Copy Assignment operator MyClass&amp; operator=(const MyClass&amp; o) { _my_dependency = o._my_dependency; // Bad ! This doesn't change where the reference is pointing to, but instead tries to modify the object that the reference points to ! Here this is a compile error because _my_dependency is a const&amp;, but if it was not const, that would be a silent bug modifying the object pointed to by _my_dependency!!! return *this; } private: const MyDependency&amp; _my_dependency; }; Copy Here is a nice article about problems around references by Herb Sutter : https://herbsutter.com/2020/02/ Also when you store a reference or a pointer, you must make sure that the pointed object outlives the class where the reference is stored ; otherwise you will get a dangling reference or pointer ! For example if your dependency lives in a std::vector, and the vector gets resized at some point, all the references to elements of that vector get invalidated ! If you stored one such reference, you are in trouble ! On the contrary if you pass a reference each frame, you will not notice the change of adress in memory at all. When you have no choice but to store the dependency​ An interesting exception to the do not store your dependencies rule is if you need your dependency in the destructor of your class (or in an operator like +=) : in those cases, you cannot pass any arguments ! Therefore you have no other choice but to store the dependency inside the class (or have it global but that would be even worse !) In such cases2, you can use a std::reference_wrapper: it will act like a reference, but still be copyable. "},{"title":"Dependency Inversion (the D of SOLID)​","type":1,"pageTitle":"Dependencies","url":"lessons/dependencies/#dependency-inversion-the-d-of-solid","content":"The interfaces should be owned by the high level that uses it, not by the low level that implements it. "},{"title":"Concepts vs Interfaces​","type":1,"pageTitle":"Dependencies","url":"lessons/dependencies/#concepts-vs-interfaces","content":"Concepts are better than interfaces because they can also require the existance of free functions, not only methods. For example if you want to require that each shape is drawable, with an interface it would require that draw() be a method of each Shape class. With concepts you can require that a free function draw(Shape const auto&amp; shape) exists for each type following the Shape concept. And free functions are great for many reasons ! (Single Responsibility Principle, Open-Close Principle, etc. See Free your functions) "},{"title":"Going further​","type":1,"pageTitle":"Dependencies","url":"lessons/dependencies/#going-further","content":"Going Further Peter Muldoon, Retiring the Singleton Pattern: Concrete Suggestions for What to use Instead (1h) About the Singleton and alternatives to it Klaus Iglberger, Breaking Dependencies: The SOLID Principles (1h) Or rather have a static instance available through a MyClass::get() method, because it gives you control over the instanciation and destruction order, which is important when you have dependencies between your singletons, and when you use multithreading.↩I met such a case when creating wrapper classes for Vulkan resources: they need a reference to the device to be destructed, so I had to store a handle to the device in each wrapper class.↩ "},{"title":"Designated Initializers","type":0,"sectionRef":"#","url":"lessons/designated_initializers/","content":"Designated Initializers","keywords":""},{"title":"Don't overfocus on performance","type":0,"sectionRef":"#","url":"lessons/dont-overfocus-on-performance/","content":"Don't overfocus on performance Because most applications don't really need performance, and correctness is their main concern. Often, the compute-heavy parts are handled by libraries and you don't need to worry about that. If the code that you write doesn't weigh much in the performance scale, don't waste time optimizing it, or worse, don't optimize it at the expense of readability / maintainability ! Sometimes you have to not be obsessed with performance and have a critical eye on wheter this performance matters. Saving 1 nanosecond every second doesn't matter to anyone! (accept maybe in high-frequency trading) Know your environment and your performance requirements, and don't push it further than you need.","keywords":""},{"title":"Documentation","type":0,"sectionRef":"#","url":"lessons/documentation/","content":"","keywords":""},{"title":"Document for users of your library​","type":1,"pageTitle":"Documentation","url":"lessons/documentation/#document-for-users-of-your-library","content":"Give examples! Ideally the code should be cimpilable as-is (no hidden information)! It also allows you to write some script that grabs all your examples and tries to run them. Write your examples as tests! "},{"title":"Document for maintainers of your library​","type":1,"pageTitle":"Documentation","url":"lessons/documentation/#document-for-maintainers-of-your-library","content":"State your intentions, the alternatives you considered, the reason that made you choose this particular implementation etc. Don't be shy, talk a lot, leave a trace for others. Even if you are unsure or not confident about your design, say it ! It will help future developers have no remorse to rewrite your code, and be confident there isn't some important thing that they are missing and that made you write the code this way. "},{"title":"Using Doxygen​","type":1,"pageTitle":"Documentation","url":"lessons/documentation/#using-doxygen","content":"Doxygen is the reference tool to generate documentation for C++ projects. It has one drawback though: the sites it generates are ugly. We can go around that by using another tool for the website part, like Sphinx: here is a nice tutorial for Doxygen + Sphinx. "},{"title":"Going further​","type":1,"pageTitle":"Documentation","url":"lessons/documentation/#going-further","content":"Going Further Christopher Di Bella &amp; Sy Brand, Documentation in the Era of Concepts and Ranges (1h) Good advice on what to put in your documentation "},{"title":"DRY: Don't repeat yourself","type":0,"sectionRef":"#","url":"lessons/dry-dont-repeat-yourself/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"DRY: Don't repeat yourself","url":"lessons/dry-dont-repeat-yourself/#brief","content":"In software development we try to avoid duplications. This helps us maintain our code because the important stuff happens in only one place and we don't have to chase the duplicated code around in our codebase when we want to make a change. There are many ways to avoid duplications: Use a loop or an algorithm, when you want to do the same thing multiple times in a row.Use a function, when you want to do the same thing in different places.Use a template, when you want to do the same thing but for different types.Use a struct or a class, when you want to use the same group of data in different places.Use a macro, (😬1) when you can't use any of the above methods, and have the courage to write and maintain some ugly macro-based code. (Honestly I believe that in most cases duplications are less of an evil than complicated metaprogramming based on macros, so I wouldn't recommend going down the route of macros most of the time). If you really need macros to do complicated things, take a look at libraries like Boost.Hana. Tip Code duplication doesn't mean textual duplication, but knowledge duplication. For example, this is not violating DRY even though the text is the same in two places: bool age_is_valid(int age) { return 0 &lt; age &amp;&amp; age &lt; 18; } bool order_is_valid(int amount) { return 0 &lt; amount &amp;&amp; amount &lt; 18; } Copy It is feasible that we will need to change order_is_valid while keeping age_is_valid the same, and it wouldn't be practical to do if the code had been refactored away. In this example the duplication is a coincidence, not a fondamental property of our domain model. See also: Tony Van Eerd, SOLID, Revisited (6min). "},{"title":"Going further​","type":1,"pageTitle":"DRY: Don't repeat yourself","url":"lessons/dry-dont-repeat-yourself/#going-further","content":"Going Further DRY - The Evils of Duplication, Chapter 2 of The Pragmatic Programmer (10min, I can lend you the book) Unfortunately there are still some (very rare) use cases for macros. Hopefully those will disappear once we get reflection and proper metaprogramming in the language, which should come for C++26 or C++29.↩ "},{"title":"Error Handling","type":0,"sectionRef":"#","url":"lessons/error-handling/","content":"","keywords":""},{"title":"Exceptions​","type":1,"pageTitle":"Error Handling","url":"lessons/error-handling/#exceptions","content":"Despite their bad reputations, they are actually pretty good and you should consider using them. Here is a very nice paper by Bjarne Stroustrup defending them : http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf(answering to a discussion opened by https://www.youtube.com/watch?v=GC4cp4U2f2E) "},{"title":"Enums","type":0,"sectionRef":"#","url":"lessons/enums/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Enums","url":"lessons/enums/#brief","content":"If you are used to using integer constants to express different possible situations, then don't! Enums are meant to do exactly that and are way clearer to read! // Bad, you need comments to indicate what the numbers mean! void Character::move(int direction) { switch(direction) { case 0: // North /*...*/ case 1: // East /*...*/ case 2: // South /*...*/ case 3: // West /*...*/ default: /*...*/ } } Copy // Good, the meaning is incorporated in the names of the enum and its values! enum class Direction { North, East, South, West, }; void Character::move(Direction direction) { switch (direction) { case Direction::North: /*...*/ case Direction::East: /*...*/ case Direction::South: /*...*/ case Direction::West: /*...*/ default: /*...*/ } } Copy "},{"title":"Use enum class, not enum​","type":1,"pageTitle":"Enums","url":"lessons/enums/#use-enum-class-not-enum","content":"enum class was introduced in C++ as a better version of the enum from C. An enum class doesn't allow implicit conversion with ints and other enums, and gives a proper namespace to your values! Bad, there is no type checking that ensures we use the right enum enum Direction { Left, Right, Up, Down }; enum CardinalDirection { North, East, South, West }; void move(CardinalDirection direction); move(Left); // Bad, this compiles but doesn't do what we want! It will move North! Copy Bad, this doesn't compile because we are defining two Ok values in the global namespace enum FilesystemError { Ok, // Should be renamed to fs_Ok to avoid conflicting with the other `Ok` ErrorNoPermission, // etc. } enum DatabaseError { Ok, // Should be renamed to db_Ok to avoid conflicting with the other `Ok` ErrorConnectionLost, // etc. } /// /// This is equivalent to defining integer constants in the global namespace: /// static constexpr int Ok = 0; static constexpr int ErrorNoPermission = 1; static constexpr int Ok = 0; // Bad, conflicts with the first Ok static constexpr int ErrorConnectionLost = 1; Copy All of these problems disappear with enum class: Good, the type checking makes sure we use the right enum enum class Direction { Left, Right, Up, Down }; enum class CardinalDirection { North, East, South, West }; void move(CardinalDirection direction); move(Direction::Left); // Good, this doesn't compile and gives us a clear error message Copy Good, this works just fine and we don't need to give weird prefixes to our enum values enum class FilesystemError { Ok, ErrorNoPermission, // etc. } enum class DatabaseError { Ok, ErrorConnectionLost, // etc. } Copy "},{"title":"using enum​","type":1,"pageTitle":"Enums","url":"lessons/enums/#using-enum","content":"Since C++20 you can have a nicer syntax: using enum allows you to skip the enum name in all your switch cases: void Character::move(Direction direction) { using enum Direction; switch (direction) { case North: // More readable than `Direction::North`. We already know that we are dealing with Directions. /*...*/ case East: /*...*/ case South: /*...*/ case West: /*...*/ default: /*...*/ } } Copy "},{"title":"Use a formatting tool","type":0,"sectionRef":"#","url":"lessons/formatting-tool/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Use a formatting tool","url":"lessons/formatting-tool/#brief","content":"Tools can format your code automatically: fix indentation, add spaces consistently, put curly braces where you want them, etc.It saves a lot of time because it means you don't have to worry about it and do it manually! Also, it ensures a consistency in style across the whole codebase and all the developers. "},{"title":"Details​","type":1,"pageTitle":"Use a formatting tool","url":"lessons/formatting-tool/#details","content":"For C++, Clang format is the most popular one and I would recommend it. Here is how to set it up: Install it on your computer. For Linux it is just a matter of using sudo apt install clang-format.Install the associated VSCode extension that will automatically run it on your code: xaver.clang-format.Go to your VSCode settings and: set Default Formatter to Clang-Formatenable Format on Save You will also need to put a configuration file named .clang-format at the root of your project to specify how the formatting should be done. You can use this great website to configure it. Or if you don't want to spend too many time tweaking it yourself, you can use mine: https://github.com/CoolLibs/Cool/blob/main/.clang-format. "},{"title":"friend","type":0,"sectionRef":"#","url":"lessons/friend/","content":"friend There are very few good reasons to use friend. The only one I can think of is when you are forced, for implementation reasons, to split something into two classes but conceptually it really is one united block. For example, when implementing the state pattern : you have a class X that holds a state S. Although S needs to be a seperate class in order to have different implementations and be changed at runtime, it really is part of X and should be allowed to access it's internals like no one else. Even in that case, you should first wonder wether it wouldn't make sense to put in your public interface all the things that S needs. If the answer is now, then maybe you have a use case for friend. What really bothers me with friend is that it is all or nothing. I wish I could specify that only one given method will be usable by a specific class : &quot;this method is not part of the public API, but it can be used by this one class who knows how to handle it&quot;. With the current friend, all friends suddenly have access to all methods and members. (Maybe this problem is lessened when the Single Responsibility Principle is strictly followed and each class really is an all or nothing package (since there is only one thing in the package), but still I don't like the fact the friends can access member variables) =&gt; Useless since C++20 and modules, which allow us a much finer grain control over visibility PassKey idiom","keywords":""},{"title":"Git Pull Requests","type":0,"sectionRef":"#","url":"lessons/git-pull-request/","content":"Git Pull Requests (also known as merge requests in GitLab)","keywords":""},{"title":"Functional programming","type":0,"sectionRef":"#","url":"lessons/functional-programming/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Functional programming","url":"lessons/functional-programming/#brief","content":"Functional programming is an important paradigm. A lot of very good techniques have emerged from this field and have been incorporated in many languages, including C++. std::optional, std::variant, std::transform and many others are inherited1 from Functional Programming. "},{"title":"Going further​","type":1,"pageTitle":"Functional programming","url":"lessons/functional-programming/#going-further","content":"Going Further Scott Wlaschin, The Power of Composition (1h) A sweet intro to some functional concepts Sy Brand, Building an Intuition for Composition (1h) Gabriel Lebec, Fundamentals of Lambda Calculus &amp; Functional Programming in JavaScript (1h) The theory behind functional programming Scott Wlaschin, The Functional Programmer's Toolkit (1h) Mark Seemann, Functional architecture - The pits of success (1h) Richard Feldman, Why Isn't Functional Programming the Norm? (45min) Scott Wlaschin, Functional Design Patterns (1h) Notice the pun 😉↩ "},{"title":"Git submodules","type":0,"sectionRef":"#","url":"lessons/git-submodules/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Git submodules","url":"lessons/git-submodules/#brief","content":"Submodules are used to link to other repositories: instead of copying a library into your project, you can use a submodule to keep a reference to the original repository. This has several advantages: It doesn't take space on your repo: it is merely a link and people can download it if they want toIt is easier to update: you simply have to pull from the original repositoryYou always know which version of the library you are using: it is written in the Git submoduleIf this is a library that you are developing, you can make the modifications in the project that uses the library, and then push to the repo of the library! This is the biggest selling point to me because it means that you can, in one place, work on the library and the project that uses it. It feels like you have one repo even though there are actually two and one of them can be shared across many projects. "},{"title":"Adding a submodule​","type":1,"pageTitle":"Git submodules","url":"lessons/git-submodules/#adding-a-submodule","content":"With GitKraken you can simply click the Add submodule button and then specify the url of the repo and the folder where you want to clone the submodule:  With the command line you can do: git submodule add https://github.com/url/to/the/repo folder/where/to/clone git submodule update --init --recursive Copy "},{"title":"Cloning a project that uses a submodule​","type":1,"pageTitle":"Git submodules","url":"lessons/git-submodules/#cloning-a-project-that-uses-a-submodule","content":"It doesn't work really well with GitKraken so I recommend to do that step with the command line: git clone --recursive https://github.com/url/to/the/repo Copy If you forget to use that --recursive flag, the submodules won't be cloned. To fix that you can always do: git submodule update --init --recursive Copy "},{"title":"Use Git","type":0,"sectionRef":"#","url":"lessons/git/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Use Git","url":"lessons/git/#brief","content":"git is probably the most important tool of all in your programmer toolbelt! It is a software which is able to handle a giant history of all the changes you ever made to your code. It is very powerful to work with other developers and split your tasks.1 "},{"title":"Why bother?​","type":1,"pageTitle":"Use Git","url":"lessons/git/#why-bother","content":"There are a few reasons to use git: revert: Go back in time to a working state if you broke something.checkout: Check how the project was at a given date.commit: Be able to work step-by-step by grouping your changes with a description.blame: Be able to know when a line of code was added, and by whom.push: Have a copy of your code on a server so that other developers can get it.pull: Get changes made by other developers.  "},{"title":"The big picture​","type":1,"pageTitle":"Use Git","url":"lessons/git/#the-big-picture","content":"The usual setup when you use git is to create a remote depot that is used as a central authority (often this is GitHub, but many other providers exist like GitLab). Authorized developers clone the content on their computer, make modifications, and push their changes back to the depot so that everyone can get it.  It is also possible to work only locally (which is great for a simple test project or exercises). Simply open a command line and type git init and you can skip the &quot;inital setup&quot; from the next section. It is still possible afterwards to publish your local repository to GitHub though. "},{"title":"Step by step​","type":1,"pageTitle":"Use Git","url":"lessons/git/#step-by-step","content":"tip These steps are presented with the command line so that you get a better understanding of git. Yet I strongly recommend that you use a software to abstract this for you. You can check the next section for some advice on that. "},{"title":"Initial setup​","type":1,"pageTitle":"Use Git","url":"lessons/git/#initial-setup","content":"You first need to install git and go through the setup. Then you can go to GitHub, create a new account, and create a new repository (should be a green button on the &quot;Repositories&quot; left panel). Once created, you will be able to clone it on your computer. To do so, open a command line in the folder you want you repository to be in, and run git clone your_repo_url. Replace &quot;your_repo_url&quot; with the one given by GitHub, when you click on the &quot;code&quot; green button.  "},{"title":"Work routine​","type":1,"pageTitle":"Use Git","url":"lessons/git/#work-routine","content":"There are only a handful of commands that are useful on a day-to-day basis. Here is how it works: After making some changes, you have to select the file that you wish to commit to the remote repo. To select all changed files run git add .  When you are happy with your changes, you can save them in a group that will be stored locally. To do so run git commit -m &quot;Place a description of your changes here&quot;.  Then it is time to make you local commit accessible to others via the remote repository. Simply run git push.  In order to get the latest changes from the remote repository it is recommended to frequently run git pull (in particular, always before calling git push). If you work with other developers it is possible that you encounter conflicts if you made changes at the same place in the same files. In this case, check out the section about resolving conflicts.  You might also have heard about branches. This is an advanced git feature, you likely don't need to use it for your first student projects. If you are curious check out the Advanced Git features. "},{"title":"Using a graphical interface​","type":1,"pageTitle":"Use Git","url":"lessons/git/#using-a-graphical-interface","content":"There are a lot of softwares that make the previous steps easier to do and monitor. I would recommend GitKraken for the job. It is free to use for public repositories, has a nice interface and a great set of features.2 They also have a Youtube channel with tons of concise tutorials to get started. "},{"title":"Handling conflicts​","type":1,"pageTitle":"Use Git","url":"lessons/git/#handling-conflicts","content":"A conflict happens when you made changes in the same place as another developer, but their changes are more recent. In this case you will have to use an external tool to compare the changes and merge them into a valid file. GitKraken is a great tool to handle these situations: check out this tutorial to get started. "},{"title":"Good practices​","type":1,"pageTitle":"Use Git","url":"lessons/git/#good-practices","content":""},{"title":"Small commits​","type":1,"pageTitle":"Use Git","url":"lessons/git/#small-commits","content":"As soon as you have made meaningful progress and the code compiles, make a commit! Try to avoid putting unrelated changes in the same commit: split them over several commits. "},{"title":"Clear messages and descriptions​","type":1,"pageTitle":"Use Git","url":"lessons/git/#clear-messages-and-descriptions","content":"Don't be lazy, write actual sentences without stripping words! In the description, explain why you are making the change. Be clear about which part of the code is affected by the changes. I (and others) like to put this inside [ ] at the beginning of the message. It is great to distinguish different types of commit by starting the message with a keyword: Add: adds a new feature / class / function.Update: improves / changes an existing feature / class / function.Fix: fixes a bug.etc. Here are some example messages I would write: [guess_the_number] Add get_int_from_user() Copy [CMake] Modernize set(EXECUTABLE_OUTPUT_PATH . . .) Copy [hangman] Fix missing include Copy "},{"title":"Don't commit broken code​","type":1,"pageTitle":"Use Git","url":"lessons/git/#dont-commit-broken-code","content":"Always make sure the code compiles before commiting it! This can especially happen after a merge or a conflict resolution: so please check that the code is still working before commiting the resolved conflict! "},{"title":"Double check​","type":1,"pageTitle":"Use Git","url":"lessons/git/#double-check","content":"Read all your changes before commiting them! It will make sure you don't commit temporary debug code (as I have done way too many times), and it is a good opportunity to review all your changes and make sure you are happy with them. NB: There are many other software versioning solutions out there, but git is by far the most popular one.↩Another great git UI is Fork if you are tired of how laggy GitKraken can sometimes be.↩ "},{"title":"Use an IDE","type":0,"sectionRef":"#","url":"lessons/ide/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide/#brief","content":"An IDE (Integrated Development Environment) is like a text editor, but way more powerful! It has a lot of additional features that will help you write, run and debug your code! I personally use and recommend Visual Studio Code (VSCode for short). "},{"title":"Extensions​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide/#extensions","content":"There are many extensions that can help you! Check out the recommended extensions for your language or discover what other people use. Here are some great extensions for VSCode that I recommend: ms-vscode.cpptools-extension-pack: The Basic C++ extensionscoenraads.bracket-pair-colorizer-2: This colors matching pairs of brackets; it makes the code more readablems-vsliveshare.vsliveshare: This allows you to work remotely with your teammates in one single editor. It is amazing to work together! "},{"title":"Quick actions​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide/#quick-actions","content":"Below are a few of the most important things that an IDE will help you with; I will demonstrate them using VSCode but rest assured that any other IDE will have the same functionalities. Please note that most of these actions are only available if ms-vscode.cpptools-extension-pack is installed in your VSCode. "},{"title":"Rename​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide/#rename","content":"Right-click on any name and choose Rename Symbol (or put your text cursor on a name and use the shortcut F2). It is better than doing a &quot;Find and Replace&quot; because &quot;Rename Symbol&quot; is content-aware; e.g. if you rename a class called &quot;Point&quot; to something else it will not affect another class called &quot;Point2D&quot;.  "},{"title":"Go to definition​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide/#go-to-definition","content":"This will take you directly to the definition of the variable / function / class. This is the functionality I use the most to move around my code. And if you want to stay focused on the portion of code you are currently editing you can also Peek at the definition and it will open a small window inside your current file.  "},{"title":"Go to symbol​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide/#go-to-symbol","content":"This allows you to quickly jump to a method in a file; the shortcut is CTRL + SHIFT + O and then you can type in what you are looking for. It is also super useful to outline the structure of a file.  "},{"title":"Go to file​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide/#go-to-file","content":"If you know which file you want to open it is blazing fast to press CTRL + P and type what you need.  "},{"title":"Switch between .h and .cpp​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide/#switch-between-h-and-cpp","content":"Use ALT + O to quickly switch between the header and the implementation file. Very useful when you are writing code for a class. "},{"title":"Find all references​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide/#find-all-references","content":"This allows you to find all the places where a symbol is used. Simply right-click on a variable or method and select Find All References to get this panel to open. Just like the Rename Symbol action it is context-aware and is supposed to only return the correct variable (if another one has the same name, it won't show up).  "},{"title":"Search for a word in the current file​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide/#search-for-a-word-in-the-current-file","content":"Useful to find you way around, simply press CTRL + F to open this popup and search what you need. The arrow on the left allows you to rename the occurrences you found, which can be useful.  "},{"title":"Search for a word in the whole project​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide/#search-for-a-word-in-the-whole-project","content":"If you need to find something fast and easy, run CTRL + SHIFT + F, enter the object of desire and press enter. The VSCode search bar is awesome and won't let you down, you can even batch-rename things there! As a side note, it is also great to be able to limit the search to a specific folder, the option is available when you press the three dots on the right.  "},{"title":"Launching the project​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide/#launching-the-project","content":"Once you have the CMake setup done (either by using the template project or by doing it yourself) you can build the project by pressing F7 or run it using CTRL + F5. "},{"title":"#if defined()","type":0,"sectionRef":"#","url":"lessons/if-defined/","content":"#if defined() #if defined(SOMETHING) offers more flexibility than #ifdef SOMETHING. For example you can use negation, and and or : #if defined(SOMETHING) &amp;&amp; !defined(SOMETHING_ELSE) You can also it with #elif : #if defined(MACRO1) // ... #elif defined(MACRO2) // ... #elif defined(MACRO3) // ... #else // ... #endif Copy","keywords":""},{"title":"Immediately Invoked Function","type":0,"sectionRef":"#","url":"lessons/immediately-invoked-function/","content":"Immediately Invoked Function","keywords":""},{"title":"Lambda functions","type":0,"sectionRef":"#","url":"lessons/lambda/","content":"Lambda functions","keywords":""},{"title":"Install a compiler","type":0,"sectionRef":"#","url":"lessons/install-a-compiler/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Install a compiler","url":"lessons/install-a-compiler/#brief","content":"A compiler is a program that takes your C++ code and creates an executable out of it. Needless to say that it is quite important to have as a C++ developer. "},{"title":"Installation​","type":1,"pageTitle":"Install a compiler","url":"lessons/install-a-compiler/#installation","content":"WindowsLinuxMac You will find all the explanations you need here (NB: you only need to follow the Prerequisites section). I will just add that while you install MSVC, after selecting Desktop development with C++, in the Installation details on the right you must also check C++ Clang tools for Windows (We will need it later when we install some tools). Then install CMake: go here and download and run the Windows x64 Installer. "},{"title":"Verification​","type":1,"pageTitle":"Install a compiler","url":"lessons/install-a-compiler/#verification","content":"You should now be able to build this sample project. If you are using VSCode you just need the ms-vscode.cpptools-extension-pack and then use the launch button at the bottom of your VSCode:  "},{"title":"Linked lists","type":0,"sectionRef":"#","url":"lessons/linked-list/","content":"Linked lists Linked lists are rarely usefull. All the theoretical advantages in insertion time and what not are actually murdered by the awfull cache coherency that make them actually very slow. The only real I know them is that they never invalidate refercences.","keywords":""},{"title":"Markdown","type":0,"sectionRef":"#","url":"lessons/markdown/","content":"","keywords":""},{"title":"Subtitle​","type":1,"pageTitle":"Markdown","url":"lessons/markdown/#subtitle","content":""},{"title":"Sub-subtitle​","type":1,"pageTitle":"Markdown","url":"lessons/markdown/#sub-subtitle","content":"italic text bold text a link Abulletpointlist tip As you can see the Markdown syntax is very light and doesn't hurt the source text's libility (unlike html). You can learn more about the Markdown syntax here. "},{"title":"Make it work, then make it good","type":0,"sectionRef":"#","url":"lessons/make-it-work-then-make-it-good/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Make it work, then make it good","url":"lessons/make-it-work-then-make-it-good/#brief","content":"No matter all the other advice I am gonna give you, always remember this one: If you can't find the &quot;perfect&quot; solution, if you know that there must be a simpler way but can't figure out what it is, then don't worry and do what works for you! The most important quality of a piece of code is that it works. All the other advice in the other lessons are just here to help you write working code, and make sure it keeps working over time when you make changes to it or to the code surrounding it. It is completely OK if you do some copy-paste, some duplication, some not-so-good names while you are trying to get something to work. I don't want you to get paralyzed by all the other considerations about clean code. But beware! I never said not to care about the quality of your code! Just that this concern should come in a second pass, once you already have a working piece of code. At that point, don't move on to the next feature! Go back to the code you just wrote, read it critically, and try to improve it! Refactor duplicated code, split complicated functions into smaller ones, create structs to hold the data that belongs together, etc. Basically, try to apply all the things you will learn in the next lessons. tip Over time you will realize that – as you get used to writing clean code – you will start to write better code even during the first prototyping pass. But until then, don't feel compelled to produce the best code ever in the first pass. "},{"title":"Measuring performance","type":0,"sectionRef":"#","url":"lessons/measuring-performance/","content":"Measuring performance","keywords":""},{"title":"Master your IDE","type":0,"sectionRef":"#","url":"lessons/master-your-ide/","content":"","keywords":""},{"title":"Learn the shortcuts​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#learn-the-shortcuts","content":"My tip is to try, once in a while, to pick an action that you often need (like deleting a whole line, selecting all the occurences of a word in the text, opening the Settings menu, etc.) and go search for the shortcut (either on the Internet or in the great VS Code shortcut menu (in File-&gt;Preferences-&gt;Keyboard Shortcuts)). And if you don't like the default shortcut, you can always change it! tip Take the time to learn! Next time you say &quot;Oh I wish I knew how to do xxx faster!&quot; take the time to learn how to do it! It will save you a lot of time later down the road! You can also discover shortcuts by watching other people write code. Take the time to ask them what the shortcut is, or go search for it! "},{"title":"Adapt the Settings​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#adapt-the-settings","content":"Take the time to open the Settings menu of your IDE, and read through it! You will discover a lot of the hidden functionalities of your IDE, and you might be able to change its behaviour to better suit your needs! I often feel silly when I discover that the functionality I was dreaming of was actually available, waiting for me to enable it. Same for the extensions you use: they can be configured in a lot of different ways, so check out their settings! (For example, did you know that you can tell the CMake extension where your CMakeLists.txt is? It doesn't have to be at the root of the project!) "},{"title":"A few great actions​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#a-few-great-actions","content":"Do you know how to do each of these? If not, try to learn them one by one: "},{"title":"Select multiple occurences of the same word​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#select-multiple-occurences-of-the-same-word","content":""},{"title":"Delete the current line​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#delete-the-current-line","content":""},{"title":"Move the current line up​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#move-the-current-line-up","content":""},{"title":"Duplicate the current line​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#duplicate-the-current-line","content":""},{"title":"Go to a file​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#go-to-a-file","content":"CTRL + P "},{"title":"Switch between a header file and the corresponding .cpp file​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#switch-between-a-header-file-and-the-corresponding-cpp-file","content":""},{"title":"Close all open tabs​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#close-all-open-tabs","content":""},{"title":"Save all open tabs​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#save-all-open-tabs","content":""},{"title":"Launch the project​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#launch-the-project","content":""},{"title":"Build the project​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#build-the-project","content":""},{"title":"Debug the project​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#debug-the-project","content":""},{"title":"Go to definition​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#go-to-definition","content":""},{"title":"Find all occurences​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#find-all-occurences","content":""},{"title":"Search for a word in the current file​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#search-for-a-word-in-the-current-file","content":""},{"title":"Search for a word in the whole project​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#search-for-a-word-in-the-whole-project","content":""},{"title":"Rename​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#rename","content":""},{"title":"Putting multiple cursors at once​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#putting-multiple-cursors-at-once","content":""},{"title":"Opening a new window​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#opening-a-new-window","content":""},{"title":"Opening another project / folder​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#opening-another-project--folder","content":""},{"title":"Multithreading","type":0,"sectionRef":"#","url":"lessons/multithreading/","content":"Multithreading jthread in C++20","keywords":""},{"title":"Move semantics","type":0,"sectionRef":"#","url":"lessons/move-semantics/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Move semantics","url":"lessons/move-semantics/#brief","content":"You all know what copying an object means. But did you know that we can do better in some circumstances? move is an optimization of copy. For example consider: std::vector&lt;int&gt; create_n_integers(int n) { std::vector v; for (int i = 0; i &lt; n; ++i) { v.push_back(n); } return v; } std::vector&lt;int&gt; my_vector = create_n_integers(10000000); Copy It might look like we are doing a copy: a vector is created inside create_n_integers and then when we do my_vector = create_n_integers(10000000) we copy the vector from create_n_integers into my_vector. And you know that a vector can be big and therefore its copy can be expensive! All of that is true, but the above code is still perfectly fine. This is because the compiler knows that there is no need to do a copy and that it can do a move instead: same effect, but faster. So, what exactly is a move? The idea is that when an object is about to be destroyed, there is no need to keep that object intact; our &quot;copy&quot; operation is therefore allowed to modify it. That &quot;destructive copy&quot; is called a move. Why would modifying the &quot;copied&quot; object be useful? Let's take the example of a std::vector&lt;int&gt; v1. A vector is implemented as a pointer to an array of elements on the heap. If we ask for a copy of the vector (std::vector&lt;int&gt; v2 = v1;) then it has to copy all the elements of the array into a new array, because we want v1 and v2 to be independent objects. If we were to only copy the pointer, then v1 and v2 would point to the same array and modifying v1 would also affect v2, which would be very confusing and impractical. Therefore making a copy of a big vector is slow because each of the (possibly many) elements of the vector has to be copied. But if we know that v1 is no longer used, then we don't care if it points to the same array as v2! There is no way of touching v1 and accidentaly modifying v2! In that case we can simply copy the pointer and save a lot of time. tip This is the power of move: the compiler optimizes your copy when it knows that you won't see the difference between a copy and a move. So, do you need to think about move all the time? Luckily, no! It will happen automatically in places where it can. Just remember that having a function that returns a vector by value is not a bad thing because the copy will be optimized into a move, which is cheap. Another explanation The Cherno, Move Semantics in C++ (13min) "},{"title":"Implementing move for your own classes​","type":1,"pageTitle":"Move semantics","url":"lessons/move-semantics/#implementing-move-for-your-own-classes","content":"For most of your classes a move constructor will be defined automatically (just like the copy constructor) and you have nothing to do. The only time when you need to implement move yourself is if your class has an explicitly defined destructor or copy constructor (see The Rule of 5). This should be rare because if all the members of your class already have move and destruction defined, then your class will get a default move and destructor that will do the right thing and everything will be fine. The only case where you would need to define destruction and move is when you manage a resource like a pointer, an object from a C api that needs to be freed, etc. Note that in the case of a pointer the problem is already solved by std::unique_ptr and std::shared_ptr. Please don't allocate your pointers with raw new and don't add destructors to your classes just to manage the pointers that you allocated. Use std::unique_ptr instead and you won't even need to think about destructors and move constructors. If you ever need to create a wrapper similar to a std::unique_ptr for some resource (like an OpenGL id), here is how to do it: class UniqueBuffer { public: UniqueBuffer() { glGenBuffers(1, &amp;_id); // Do whatever you need to create the resource } ~UniqueBuffer() { glDeleteBuffers(1, &amp;_id); // Do whatever you need to delete the resource } UniqueBuffer(const UniqueBuffer&amp;) = delete; // We disable copying UniqueBuffer&amp; operator=(const UniqueBuffer&amp;) = delete; // We disable copying UniqueBuffer(UniqueBuffer&amp;&amp; rhs) noexcept // Move constructor : _id{rhs._id} { rhs._id = 0; // Make sure that rhs won't delete the _id we just copied } UniqueBuffer&amp; operator=(UniqueBuffer&amp;&amp; rhs) noexcept // Move assignment operator { if (this != &amp;rhs) { // Make sure that we don't do silly things when we try to move an object to itself glDeleteBuffers(1, &amp;_id); // Delete the previous object _id = rhs._id; // Copy the object rhs._id = 0; // Make sure that rhs won't delete the _id we just copied } return *this; // move assignment must return a reference to this, so we do it } GLuint operator*() const { return _id; } // The getter for the wrapped `_id`. You can also have it as a function called id() but I like to use the dereference operator for that purpose (*my_wrapper). private: GLuint _id; }; Copy Many things to note: We disable copying because we can't simply copy the _id (the copy would refer to the same object as the original, which would be problematic just like in our vector example), and we can't create a new object with glGenBuffers because we have no idea what was stored in that buffer by users (if we were to do a naive copy constructor, then when users ask for a copy they would get a new empty buffer instead of a copy of all the vertex data or whatever that was added to the buffer). Disabling copy also prevents accidental copies of objects that are not supposed to be copied (e.g. because they are big and the copy would be expensive).We do rhs._id = 0; when we move. This is because if we don't, then when rhs gets destroyed it will destroy its _id, which is the same as what our new object is using, which would make it invalid!We do if (this != &amp;rhs). This is because someone could call v = std::move(v); (in generic code it can happen and it is not that obvious and sometimes you need to do it). In such cases without the check we would do rhs._id = 0; but since rhs is ourself we would just loose our _id!The signature for move operations contains UniqueBuffer&amp;&amp;. This &amp;&amp; symbol is called an r-value reference; it is kind of like the usual reference &amp; (called an l-value reference) but it indicates that you are allowed to modify the object and steal its resources. Basically it means that it is okay to move from the object. The move constructor and move assignment are marked noexcept which is extremely important. If you don't then STL containers like vector will not use your move and will do a copy instead (because it would be problematic if an exception was thrown while a vector is resizing and moving objects to the new location). This noexcept costs you nothing and allows great performance improvements when you store your objects in a vector, so please don't forget it! tip Make your wrappers as small as possible. Because if you need to define a move constructor in a big class then you need to tell it to move each member variable, which is tedious and error prone. Plus you will probably need that resource in several classes and you don't want to have to repeat the destruction code in each of them. You can find examples of such wrappers in GL++. "},{"title":"Asking for a move with std::move​","type":1,"pageTitle":"Move semantics","url":"lessons/move-semantics/#asking-for-a-move-with-stdmove","content":"Move happens automatically: When returning from a functionWhen passing a temporary value to a function (a.k.a. something that was not put in a variable). In f(MyClass{1, 3});, MyClass{1, 3} is not given any name: it is a temporary and will be moved into f instead of copied. But if you have std::vector&lt;MyClass&gt; v; MyClass my_class{1, 3}; // Maybe do something with my_class // . . . v.push_back(my_class); Copy when passing my_class to push_back it will be copied instead of moved. But let's say that we don't need my_class after the call to push_back: then it would be nice to move my_class into push_back and avoid a copy. We can ask for that by doing v.push_back(std::move(my_class));. This works because push_back is overloaded to accept both normal references (const MyClass&amp;) and r-value references (MyClass&amp;&amp;). caution After calling std::move() on an object, don't use it again! It has been moved away and might not be valid anymore. To learn more on that, check out Beware: Zombies. "},{"title":"Return value optimization (RVO)​","type":1,"pageTitle":"Move semantics","url":"lessons/move-semantics/#return-value-optimization-rvo","content":"Sometimes the compiler can do even better than move. When you are returning an unnamed variable from a function you are guaranteed that there won't even be a move, the variable will be created in place at the call site. This is called RVO and is guaranteed by the standard. std::vector&lt;int&gt; create_some_vector(int x) { int a = x + 1; int b = x * 2; return std::vector&lt;int&gt;{{a, b}}; // RVO applies because we did not give a name to the variable std::vector&lt;int&gt;{{a, b}}, we returned it directly } std::vector&lt;int&gt; v = create_some_vector(2); // No copy nor move. It is the same as doing std::vector&lt;int&gt; v = {2 + 1, 2 * 2}; Copy Compilers can do other optimizations, but RVO is (currently) the only one that is guaranteed. In our first example RVO doesn't apply because we gave a name to the variable that we return (v). But chances are your compiler will still optimize the move away; this is known as NRVO (Named Return Value Optimization). "},{"title":"Going further​","type":1,"pageTitle":"Move semantics","url":"lessons/move-semantics/#going-further","content":"Going Further Titus Winters, Abseil tip (5min) Klaus Iglberger, Back To Basics: The Special Member Functions (1h) Arthur O'Dwyer, Return Value Optimization: Harder Than It Looks (25min) "},{"title":"Naming","type":0,"sectionRef":"#","url":"lessons/naming/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Naming","url":"lessons/naming/#brief","content":"Naming is very important because this is your first and most powerful tool to communicate with the other developers (and with yourself in the future). It is very important that you pick your names carefuly, take the time to mature your design, and change the names whenever you realize they don't quite describe what your object is or does anymore. tip Take the time to rename whenever you notice a name that is not quite accurate! Use the features of your IDE to make the renaming easy. The greatest names are both consise and descriptive: they encapsulate a concept perfectly and everybody can wrap their head around them easily. The next best thing are names that are long, but still descriptive. The fact that you need a &quot;sentence&quot; to describe your object might indicate that you don't fully understand the abstraction behind it, or that you have a design flaw (maybe your function tries to do several things at once and should be split, or maybe your class has more than one responsibility). Nevertheless it is still a decent name and you can live with it for a while. The last kind of names are the ones that are obscure (or worse, lies); those are inacceptable! tip I could not do a better job than Kevlin Henney already did, so please watch those 10 minutes of his conference, starting at 41:30 Kevlin Henney, Clean Coders Hate What Happens to Your Code When You Use These Enterprise Programming Tricks "},{"title":"Anecdote​","type":1,"pageTitle":"Naming","url":"lessons/naming/#anecdote","content":"Finding the right name sometimes gives you ideas of how to improve your design. For example I wanted a class to hold a width and a height to represent the size of some images. I started calling it RectangleSize to be more generic, but when I realized it was more of an ImageSize it helped me a lot! Because then I added an invariant to that class : width &gt; 0 &amp;&amp; height &gt; 0. This is very useful because most graphics APIs won't accept an empty image anyways and I was doing tests all over the place to make sure that width &gt; 0 &amp;&amp; height &gt; 0. Once I had this invariant for ImageSize I was able to use it safely without checks, since they already took place in the constructor of ImageSize. "},{"title":"Some Guidelines​","type":1,"pageTitle":"Naming","url":"lessons/naming/#some-guidelines","content":"Some of these are extracted from the Unreal Engine Coding Guidelines. "},{"title":"Name your booleans as questions or assertions​","type":1,"pageTitle":"Naming","url":"lessons/naming/#name-your-booleans-as-questions-or-assertions","content":"To make it clear what true and false mean: // Bad, what does true mean? bool CheckTea(Tea tea); // Good, the name makes it clear that true means the tea is fresh bool IsTeaFresh(Tea tea); // Also good bool TeaIsFresh(Tea tea); Copy The assertion version is great because it makes your code read as an actual sentence: if (TeaIsFresh(myTea)). On the other hand the question version is great because the first word (is, has, does, etc.) makes it instantly clear that this is a boolean. "},{"title":"Avoid abbreviations​","type":1,"pageTitle":"Naming","url":"lessons/naming/#avoid-abbreviations","content":"What is obvious to you might not be obvious to everybody. Instead of taking the risk, just take the time to type a few more letters 😉. Only use abbreviations if you are relying on a well established convention, like id for identifier. For example the Bloomberg Coding Standards define a list of allowed abbreviations that everyone should know the meaning of (See Section 3.4.3). // Bad. Can you guess what this stands for? int calc_rev_diff(); // Good, no guessing involved int calculate_revenue_difference(); // Bad (although we have gotten used to it so this is now an OK convention) void mkdir(); // Good, much clearer to everybody, especially to newbies void make_directory(); Copy "},{"title":"Use variables or functions to split complicated statements​","type":1,"pageTitle":"Naming","url":"lessons/naming/#use-variables-or-functions-to-split-complicated-statements","content":"Because it is faster to read than a comment, and can't be outdated: // Bad, difficult to understand if ((Blah-&gt;BlahP-&gt;WindowExists-&gt;Etc &amp;&amp; Stuff) &amp;&amp; !(PlayerExists &amp;&amp; GameStarted &amp;&amp; PlayerStillHasPawn &amp;&amp; IsTuesday()))) { DoSomething(); } // Good, way easier to understand const bool WindowIsValid = Blah-&gt;BlahP-&gt;WindowExists-&gt;Etc &amp;&amp; Stuff; const bool PlayerIsDead = PlayerExists &amp;&amp; GameStarted &amp;&amp; PlayerStillHasPawn &amp;&amp; IsTuesday(); if (WindowIsValid &amp;&amp; !PlayerIsDead) { DoSomething(); } Copy "},{"title":"Append \"out\" to non-const reference parameters​","type":1,"pageTitle":"Naming","url":"lessons/naming/#append-out-to-non-const-reference-parameters","content":"When you pass a variable by mutable reference it implies that your function will change its value. It can be better to make it explicit so that it is easier to understand what is going on. bool parseObjectFromPath(const char* aPath, Object&amp; anObjectOut) { if (const auto values = readFile(aPath)) { anObjectOut.Set(values); return true; } return false; } // ... { Object newObject; if (parseObjectFromPath(&quot;superPath/superFile&quot;, newObject)) { // Do stuff with your filled object } // ... } Copy "},{"title":"Going further​","type":1,"pageTitle":"Naming","url":"lessons/naming/#going-further","content":"Going Further Kate Gregory, Naming is Hard: Let's Do Better (1h) "},{"title":"std::optional","type":0,"sectionRef":"#","url":"lessons/optional/","content":"std::optional https://youtu.be/ojZbFIQSdl8?t=1056","keywords":""},{"title":"Pointers vs References","type":0,"sectionRef":"#","url":"lessons/pointers-vs-references/","content":"Pointers vs References Pointers can be null Pointers can be repointed https://youtu.be/YnWhqhNdYyk?t=2253","keywords":""},{"title":"Polymorphism","type":0,"sectionRef":"#","url":"lessons/polymorphism/","content":"","keywords":""},{"title":"Static Polymorphism​","type":1,"pageTitle":"Polymorphism","url":"lessons/polymorphism/#static-polymorphism","content":"Function overloading and templates. https://www.fluentcpp.com/2017/04/28/extract-interface-cpp/ "},{"title":"Dynamic Polymorphism​","type":1,"pageTitle":"Polymorphism","url":"lessons/polymorphism/#dynamic-polymorphism","content":"Base class vs std::variant. When people say why OOP is so great, the biggest (hidden) argument is most often that polymorphism is great. But beware the confusion ! OOP is not the only way of achieving polymorphism ; generic programming with std::variant is an option too. "},{"title":"Going further​","type":1,"pageTitle":"Polymorphism","url":"lessons/polymorphism/#going-further","content":"Going Further Klaus Iglberger, Embrace No Paradigm Programming! (1h) Comparison of different approaches to achieve polymorphism "},{"title":"Precompiled Header","type":0,"sectionRef":"#","url":"lessons/precompiled-header/","content":"Precompiled Header https://youtu.be/eSI4wctZUto","keywords":""},{"title":"Prefer free functions","type":0,"sectionRef":"#","url":"lessons/prefer-free-functions/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Prefer free functions","url":"lessons/prefer-free-functions/#brief","content":"tip Free functions help a lot with decoupling, code reuse, testing, etc. The problem with methods is that they depend on the whole class and, if your class is quite large (which it shouldn't be but that's a different topic) then you probably have many unnecessary dependencies. It makes it harder to reason about methods at the call site because they could use any information from the class and, if they are not const, modify any member of the class. On the other hand free functions are very clear about their dependencies: it's just the arguments of the function, nothing is hidden. And even if you pass the whole class to the function, at least it can only use the public interface of the class which greatly limits the harm it can do. NB: This doesn't mean that methods are bad or that you should never use them. If you need to encapsulate data and only access it in well defined ways, a method is the way to go. But if something can be done using only the public interface of a class, then a free function is preferable to a member function. Free functions are also very easy to reuse since they are not burried inside any class and have minimal dependencies. Check out what David Sankel has to say about this (1 minute, starting at 36:00), as well as the C++ Core Guidelines. "},{"title":"Going further​","type":1,"pageTitle":"Prefer free functions","url":"lessons/prefer-free-functions/#going-further","content":"Going Further Klaus Iglberger, Free Your Functions! (1h) Scott Meyers, How Non-Member Functions Improve Encapsulation (15min) "},{"title":"<random>","type":0,"sectionRef":"#","url":"lessons/random/","content":"&lt;random&gt; going further Stephan T. Lavavej, rand() Considered Harmful (30min)","keywords":""},{"title":"The Rule of 5","type":0,"sectionRef":"#","url":"lessons/rule-of-5/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"The Rule of 5","url":"lessons/rule-of-5/#brief","content":"The Rule of 5 states that if you write a special member function (a.k.a. a destructor, a copy constructor, a copy assignment, a move constructor or a move assignment), then you need to write all 5 of them. They will not be generated by the compiler because if you define one explicitly this probably means that the implementation that the compiler would have defined by default is not good for any of them. An example of that is an object containing a raw owning pointer: it needs to be deleted, but also when you make a copy of it you want to copy the pointed object, not the pointer, in order to preserve value semantics. If you were to copy only the pointer then the copied object would point to the same thing as the original object, they would not be independent copies. Also when the first one would be deleted it would delete the pointer that the other object also uses, and you will get a segmentation fault somewhere because the second object is still alive but the pointer it holds has already been destroyed by someone else. If you have to implement special member functions explicitly, try to make the class as small as possible. You most likely have only one member of your class that requires the destructor / copy. Then, move that member into its own class that implements the rule of 5, and in your main class use that wrapper class and let the compiler generate the destructor / move / copy. It will prevent you from forgetting to copy a member in your copy / move, or something silly of that kind. tip Most classes shouldn't have explicit special member functions: This is known as the Rule of 0. Those rare ones that need the Rule of 5 should be kept at a minimal size: only one member variable. "},{"title":"Scope guard","type":0,"sectionRef":"#","url":"lessons/scope-guard/","content":"Scope guard Conference","keywords":""},{"title":"Range-based for loop","type":0,"sectionRef":"#","url":"lessons/range-based-for-loop/","content":"Range-based for loop It helps you express your intent more clearly. If you want to go over each element once (which the case of most for loops) you can write : const std::vector v = {3, 1, 17, 8}; for (auto x : v) { // do something with x } for (const auto&amp; x : v) { // do something with x } for (auto&amp; x : v) { // do something with x } Copy It guarantees that you are not modifying the index in the body of the loop to make nasty things and change the iteration process.Having this guarantee helps people reason about your code, and this is very important ! const std::vector v = {3, 1, 17, 8}; for (size_t i = 0; i &lt; v.size(); ++i) { // Long body // Might do i++ somewhere } Copy","keywords":""},{"title":"Single Source of Truth","type":0,"sectionRef":"#","url":"lessons/single-source-of-truth/","content":"Single Source of Truth The Single Source of Truth principle is very simple : only store an information once ! And it stems from a very simple observation : if you store a value (or information that are deduced from that value) in several places, then they all need to be updated at the same time when you change that value. To do so you can try to write setter functions that will update the data in all the required places, but it is so easy to mess up, especially years in the future when someone else comes along and starts modifiyng the code. Basically it introduces oddities in the code that one must be aware of when working with it. This is why if often leads to bugs at some point ; and it also makes the code harder to reason about and maintain !","keywords":""},{"title":"Smart Pointers","type":0,"sectionRef":"#","url":"lessons/smart-pointers/","content":"Smart Pointers No naked new : this doesn't mean no dynamic allocations, it just means they should always be done through a smart pointer or a container. #include &lt;memory&gt; MyClass* x = new MyClass(); // BAD std::unique_ptr&lt;MyClass&gt; x = std::make_unique&lt;MyClass&gt;(); // GOOD std::shared_ptr&lt;MyClass&gt; x = std::make_shared&lt;MyClass&gt;(); // GOOD too, but less often what you need Copy","keywords":""},{"title":"Split problems in small pieces","type":0,"sectionRef":"#","url":"lessons/split-problems-in-small-pieces/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Split problems in small pieces","url":"lessons/split-problems-in-small-pieces/#brief","content":"If I were to sum up all the previous lessons, the most important takeaway would be: Write small things! Small functions, small classes. Create a lot of small abstractions that help you reason about your code. "},{"title":"Take small steps​","type":1,"pageTitle":"Split problems in small pieces","url":"lessons/split-problems-in-small-pieces/#take-small-steps","content":"When you are faced with a big programming task, if you don't know where to start try to split up the problem! Think about the smallest next step that you can take, that will produce a visible (testable) result and will get you ever so slightly closer to your final goal. Once split in small enough pieces, any problem should be manageable. I personally like to do the visual steps first, because then it is easier to debug / see your progress and it is more rewarding, you really feel like you are getting somewhere once something is displayed on the screen. "},{"title":"Going further​","type":1,"pageTitle":"Split problems in small pieces","url":"lessons/split-problems-in-small-pieces/#going-further","content":"Going Further Tony Van Eerd, SOLID, Revisited (1h30) "},{"title":"State and Strategy","type":0,"sectionRef":"#","url":"lessons/state-and-strategy/","content":"State and Strategy Difference : State handles the changes itself, it is an implementation of a state machine. For Strategy, the decision of changing the strategy comes from the outside, it doesn't depend on what the current strategy is.","keywords":""},{"title":"Stack vs Heap","type":0,"sectionRef":"#","url":"lessons/stack-vs-heap/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#brief","content":"There are two kinds of memory where your variables can be created: the stack and the heap. Where you choose to create them has a lot of implications, but fear not: the choice is often very easy! "},{"title":"The Stack​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#the-stack","content":"This is the default. (And a good one at that). When you say for example int i = 3; you are creating a variable on the stack. "},{"title":"The Heap​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#the-heap","content":"When you say int* i = new int; you don't get an int, you get a pointer to an int. The actual int is created far far away, in the weird country of the heap. "},{"title":"Prefer the stack​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#prefer-the-stack","content":"You should almost always be using the stack! This is both simpler and more performant.  "},{"title":"Automatic cleanup​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#automatic-cleanup","content":"Variables that are on the stack are automatically destroyed when their scope ends: Stack { int i = 3; } // i is destroyed here, no memory can ever leak Copy Heap { int* i = new int; } // The pointer is destroyed here, but not the int that it was pointing to! We have a memory leak! // To fix that we need to do: { int* i = new int; delete i; } Copy "},{"title":"Performance​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#performance","content":"Allocating on the heap is much slower than allocating on the stack! Also, accessing variables on the heap might be slower because they are more likely to be spread out all over the memory and be in different cache lines. You can read more about that here. "},{"title":"When to use the heap​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#when-to-use-the-heap","content":"There are a few good reasons to use the heap. But you should always remember that since managing heap memory is complicated you should always use standard types that will do the heavy lifting for you. For example std::vector and std::unique_ptr use heap memory, but since they encapsulate it you don't have to worry about it. That's why we can have guidelines like never write new: if you need to have something allocated on the heap, use a std::unique_ptr or a std::shared_ptr that will handle the new and the delete for you. "},{"title":"For varying-size objects​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#for-varying-size-objects","content":"For the stack to be as efficient as it is, the size of all the variables must be known at compile-time. If for example you need a resizable array (std::vector), then you have no choice but to use the heap. std::string also allocates on the heap for the same reason. "},{"title":"For big objects​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#for-big-objects","content":"When you need a lot of memory to store something like an image or a 3D model, it might not fit on the stack. In such case you will need to use the heap (probably through a std::vector to store all the pixels or vertices). This also has the advantage that all of the data won't be copied when you are returning an image from a function: only the pointer is copied, since the pointed data that lives on the heap doesn't have to move and won't be destroyed when the scope of the function ends. "},{"title":"For polymorphism​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#for-polymorphism","content":"You can't know the size of a polymorphic class at compile time because some child classes could be bigger than the parent class. You therefore have to use the heap1. class ParentClass { int x; }; class ChildClass : public ParentClass { int y; }; ParentClass my_object = ChildClass{}; // Doesn't compile because you can't fit a ChildClass (two ints) into a ParentClass (one int). ParentClass* my_object = new ChildClass{}; // Works because the size of a pointer is always the same, no matter the size of the pointed object. Copy "},{"title":"Going further​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#going-further","content":"Going Further The Cherno, Stack vs Heap Memory in C++ (20min) NB: actually you can use std::variant if you want polymorphic objects on the stack. std::variant is basically a better version of inheritance.↩ "},{"title":"Use static analysers","type":0,"sectionRef":"#","url":"lessons/static-analysers/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Use static analysers","url":"lessons/static-analysers/#brief","content":"There are a lot of bugs and bad coding habits that can be caught by tools. It can really help you a lot to improve the quality of your code! If you use the dev container of this C++ template project you will get a lot of tools installed out of the box. If not, consider using some VSCode extensions: jbenden.c-cpp-flylint and notskm.clang-tidy. Note that you will also have to install the tools that these extensions rely one (CppCheck, clang-tidy and so on). To see these tools in action, check this out. "},{"title":"Installing​","type":1,"pageTitle":"Use static analysers","url":"lessons/static-analysers/#installing","content":""},{"title":"clang-tidy​","type":1,"pageTitle":"Use static analysers","url":"lessons/static-analysers/#clang-tidy","content":"For Windows:Go to LLVM's release page and choose the right executable (e.g. LLVM-13.0.0-win64.exe). Then run the executable and it will install everything (don't forget to accept Add to PATH). Once you restart your computer the VSCode extension will be able to find the clang-tidy executable. For Linux and Mac:It should be as simple as installing it through your favorite package manager. If not, go look on the Internet! "},{"title":"The other​","type":1,"pageTitle":"Use static analysers","url":"lessons/static-analysers/#the-other","content":"They should all be straight forward to install simply by looking on the Internet. If not, please raise an issue. "},{"title":"Static site generators","type":0,"sectionRef":"#","url":"lessons/static-site-generators/","content":"Static site generators","keywords":""},{"title":"std::function","type":0,"sectionRef":"#","url":"lessons/std-function/","content":"std::function","keywords":""},{"title":"std::string and std::string_view","type":0,"sectionRef":"#","url":"lessons/string-and-string-view/","content":"","keywords":""},{"title":"string​","type":1,"pageTitle":"std::string and std::string_view","url":"lessons/string-and-string-view/#string","content":""},{"title":"string_view​","type":1,"pageTitle":"std::string and std::string_view","url":"lessons/string-and-string-view/#string_view","content":"It is a new type from C++17. It is a non-owning reference to either a const char* or a std::string. It has many advantages: providing the same API as std::string for const char* without having to pay the cost of constructing a std::string, working with const char* and std::string as if they were the same type, etc. Just remember that it is non-owning, like a reference: it is great for passing parameters around, but if you need to store it as a long-lasting variable you probably still need to use a std::string. "},{"title":"STL algorithms","type":0,"sectionRef":"#","url":"lessons/stl-algorithms/","content":"","keywords":""},{"title":"Find & find_if​","type":1,"pageTitle":"STL algorithms","url":"lessons/stl-algorithms/#find--find_if","content":""},{"title":"Filter​","type":1,"pageTitle":"STL algorithms","url":"lessons/stl-algorithms/#filter","content":""},{"title":"Map​","type":1,"pageTitle":"STL algorithms","url":"lessons/stl-algorithms/#map","content":""},{"title":"Reduce​","type":1,"pageTitle":"STL algorithms","url":"lessons/stl-algorithms/#reduce","content":""},{"title":"Testing","type":0,"sectionRef":"#","url":"lessons/testing/","content":"","keywords":""},{"title":"Unit Tests​","type":1,"pageTitle":"Testing","url":"lessons/testing/#unit-tests","content":"For example I wrote tests for the code that computes your grades: TODO PUT A LINK "},{"title":"UnitTesting libraries​","type":1,"pageTitle":"Testing","url":"lessons/testing/#unittesting-libraries","content":"There a few out there. I personaly use and recommend doctest. Other popular libraries include GoogleTest and Catch2. "},{"title":"Going further​","type":1,"pageTitle":"Testing","url":"lessons/testing/#going-further","content":"Going further Phil Nash, Test Driven C++ (1h) About TDD "},{"title":"Strong Typing","type":0,"sectionRef":"#","url":"lessons/strong-typing/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Strong Typing","url":"lessons/strong-typing/#brief","content":"Strong typing is when you create a type just to wrap an int, so that you can give that int a name, invariants, and so on. It helps you express your intent more clearly and makes your APIs harder to misuse. They are amazing and definitely worth the extra little time needed to write them down ; don't be lazy ! "},{"title":"Details​","type":1,"pageTitle":"Strong Typing","url":"lessons/strong-typing/#details","content":"Read this great article about strong types. And then look at this great example of using strong types to prevent a nasty bug. Once you are done with these, I want to give an example of my own. Consider a 2D position (a.k.a a point) and a 2D displacement (a.k.a. a vector (although that term is way too overloaded and has sadly become ambiguous)). They can both be represented with two numbers x and y even though they are very different concepts ! The fact that they are different concepts means that we can not do the same operations on them ! Strong typing can protect us from accidently doing that. For example, adding two displacements d1 and d2 makes total sense : it simply yields another displacement that is the same as moving by d1 and then by d2 :  Adding a displacement to a position is perfectly reasonable too : it moves the position :  But adding two positions doesn't make sense at all !!!  Even though it would be easy to add the representation of two positions, we want to prevent that because it would most likely be a bug or a logic error. Recap Strong typing helps us give a more concrete representation to concepts, physical units, coordinate spaces, and much more ! They prevent logic errors and make APIs clearer. Going further Strong types for physical units Abstract Algebra and Strong Types "},{"title":"Trailing return type","type":0,"sectionRef":"#","url":"lessons/trailing-return-type/","content":"Trailing return type","keywords":""},{"title":"Type design","type":0,"sectionRef":"#","url":"lessons/type-design/","content":"Type design About types to model a concept","keywords":""},{"title":"Type erasure","type":0,"sectionRef":"#","url":"lessons/type-erasure/","content":"Type erasure https://youtu.be/jKt6A3wnDyI","keywords":""},{"title":"Use libraries","type":0,"sectionRef":"#","url":"lessons/use-libraries/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Use libraries","url":"lessons/use-libraries/#brief","content":"In the real world no one writes everything from scratch. If you need a feature, most likely other people have had the same need before you, and chances are they made a library out of it! If you need a big thing and are almost ready to spend the next three months implementing it, it might be wise to first have a look on the internet and see if some solution already exists. Most often you will discover that there is even several of them and you will have the leisure to pick and chose the one that seems to best suit your needs. "},{"title":"How to​","type":1,"pageTitle":"Use libraries","url":"lessons/use-libraries/#how-to","content":""},{"title":"Build from source​","type":1,"pageTitle":"Use libraries","url":"lessons/use-libraries/#build-from-source","content":"Building from source means that: anyone simply has to clone your project and is guaranteed to have all the dependenciesyou never have any version conflictyou can tweak the libraries if you need to (and if their license allows so)you have quick access to the source code to read it and your IDE can jump to it To add a library to your project you can simply download the folder and copy it into your project, but a better practice is to use a Git submodule. "},{"title":"Add them to your project with CMake​","type":1,"pageTitle":"Use libraries","url":"lessons/use-libraries/#add-them-to-your-project-with-cmake","content":"If the library provides good CMake support, all you should have to do is: add_subdirectory(libname) target_link_libraries(${PROJECT_NAME} PRIVATE libname) Copy If not, then you will have to define the target and its requirements yourself. For that, check out the lesson on CMake for library authors. "},{"title":"Read the documentation​","type":1,"pageTitle":"Use libraries","url":"lessons/use-libraries/#read-the-documentation","content":"Read the doc! Really! Or at least all the tutorial and introduction parts! Whenever I finally take the time to sit down and go through the documentation of a library I use, I always end up cursing myself for not doing it earlier because I learn so much while reading it and I realize it would have saved me a lot of debugging time if I had read it before trying to blindly use the library! Plus you will discover amazing features that you were not even aware of! tip Take the time and Read the Fucking Manual. Programing is a slow and patient process. You will save time later down the road if you take the time to do things properly from the get go.  "},{"title":"std::variant","type":0,"sectionRef":"#","url":"lessons/variant/","content":"std::variant https://youtu.be/ojZbFIQSdl8?t=869https://youtu.be/ojZbFIQSdl8?t=1128 It is a very good alternative to enums, because it can contain data, and be resolved through functions overload instead of switches. To replace polymorphism made with inheritance: https://youtu.be/gKbORJtnVu8","keywords":""},{"title":"Use structs to group data","type":0,"sectionRef":"#","url":"lessons/use-structs-to-group-data/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Use structs to group data","url":"lessons/use-structs-to-group-data/#brief","content":"Structs allow you to group data together. When there are no invariants to enforce, using a struct and having all your data public is better that using a class (as explained in Design cohesive classes). Often, if you notice that you are passing the same group of parameters to a few functions, it is a great oportunity to create a struct: it will simplify parameter passing, make it easier to add a parameter to the group later, and it adds an abstraction to your code that might help you reason about it and that you might reuse later. For example, if many functions take an x and a y you might refactor this into a Point or Point2D struct. On the other hand if you need a point that is restricted to, say, a disk on the plane, then you will need a class to enforce that invariant. Moreover, if this group of parameters is supposed to have a default value, then you can encode it in the struct instead of duplicating it all over the place in all the functions that take those parameters: // Bad, we are duplicating our default values class Texture { // . . . void resize (ImageSize size, InternalFormat internal_format = InternalFormat::RGBA, Channels channels = Channels::RGBA, TexelDataType texel_data_type = TexelDataType::UnsignedByte); void upload_data(ImageSize size, const void* data, InternalFormat internal_format = InternalFormat::RGBA, Channels channels = Channels::RGBA, TexelDataType texel_data_type = TexelDataType::UnsignedByte); }; Copy // Good, we have removed some duplications and introduced a useful abstraction struct TextureLayout { InternalFormat internal_format = InternalFormat::RGBA; Channels channels = Channels::RGBA; TexelDataType texel_data_type = TexelDataType::UnsignedByte; }; class Texture { // . . . void resize(ImageSize size, TextureLayout layout = {}); void upload_data(ImageSize size, const void* data, TextureLayout layout = {}); }; Copy "},{"title":"Designated initializers​","type":1,"pageTitle":"Use structs to group data","url":"lessons/use-structs-to-group-data/#designated-initializers","content":"In C++20 structs have become even more amazing thanks to designated initializers: Given this struct struct WindowConfig { const char* title; // The title that will be displayed in the title bar of the window int initial_width = 1280; // Initial width of the window int initial_height = 720; // Initial height of the window bool cap_framerate_on_startup_if = true; // Whether the framerate should be capped or not (this can later be changed at runtime through window.cap_framerate_if()) bool maximize_on_startup_if = is_building_as(BuildMode::Release); // Whether the window will be maximized when the application starts. bool hide_on_startup_if = false; // Whether the window will be hidden when the application starts. }; Copy you can now initialize it by naming its members: const auto window_config = WindowConfig{ .title = &quot;Hello C++&quot;, .initial_width = 500, .initial_height = 500, .maximize_on_startup_if = true, }; Copy Which is much more readable than const auto window_config = WindowConfig{&quot;Hello C++&quot;, 500, 500, true, true, false}; Copy And note that you can skip some members (like cap_framerate_on_startup_if in this example). They will be initialized with their default value. "},{"title":"wasm and electron","type":0,"sectionRef":"#","url":"lessons/wasm-and-electron/","content":"wasm and electron","keywords":""},{"title":"std::vector","type":0,"sectionRef":"#","url":"lessons/vector/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"std::vector","url":"lessons/vector/#brief","content":"This is by far the best container! It can do everything and is also the most performant in almost all situations. If you use another container than std::vector you must have a very strong reason to do so! Most notably, even if std::list has a better algorithmic complexity for some operations, in most cases std::vector will still be faster in practice because it has better cache coherency (the data is grouped together in memory, which makes it much faster to access). The learn how to use std::vector watch this great tutorial by The Cherno. "},{"title":"Watch conferences","type":0,"sectionRef":"#","url":"lessons/watch-conferences/","content":"Watch conferences This is the best away to improve once you have acquired a solid basis through classes and projects.","keywords":""},{"title":"Write libraries","type":0,"sectionRef":"#","url":"lessons/write-libraries/","content":"Write libraries Even if it's only for your personal use, it will help you a lot with code reuse across projects and also inside one project. And also it will force you to make your code a little more generic, which most of the time will improve it at the same time. Moreover, it will make sure that the code is decoupled from the rest of your application. So : as soon as you are write some bit of code that is fairly generic, consider turning it into a library. For CMake refer back to here.","keywords":""},{"title":"Write small functions","type":0,"sectionRef":"#","url":"lessons/write-small-functions/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Write small functions","url":"lessons/write-small-functions/#brief","content":"Small functions are way easier to read and reason about. Here is what the Core Guidelines have to say about it. "},{"title":"Details​","type":1,"pageTitle":"Write small functions","url":"lessons/write-small-functions/#details","content":"I used to write long functions like this one, using comments to indicate the different parts of the function. I did not want to write intermediate functions because it felt silly to me to create functions that I would only use once. void View::imgui_window(ImTextureID image_texture_id, ImageSize image_size, bool need_to_fit) { if (_is_open) { ImGui::Begin(_name.c_str(), &amp;_is_open, ImGuiWindowFlags_NoScrollbar); // Update _size const auto size = ImGui::GetContentRegionAvail(); if (size.x &gt;= 1.f &amp;&amp; size.y &gt;= 1.f) { _size.emplace( static_cast&lt;ImageSize::DataType&gt;(size.x), static_cast&lt;ImageSize::DataType&gt;(size.y)); } else { _size.reset(); } // Update _position _position = ImGui::GetCursorScreenPos(); if (_size.has_value()) { // Display the image const auto fitted_image_size = need_to_fit ? ImageSizeU::fit_into(*_size, image_size) : static_cast&lt;ImageSizeT&lt;float&gt;&gt;(*_size); ImGuiExtras::image_centered(image_texture_id, {fitted_image_size.width(), fitted_image_size.height()}); _is_hovered = ImGui::IsItemHovered(); } else { _is_hovered = false; } ImGui::End(); } else { _size.reset(); _is_hovered = false; } } Copy But I had to admit that I was having trouble reading those long functions, and that maybe everyone else was right. The same code as above would look like this once split into more atomic parts : void View::imgui_window(ImTextureID image_texture_id, ImageSize image_size, bool need_to_fit) { if (_is_open) { ImGui::Begin(_name.c_str(), &amp;_is_open, ImGuiWindowFlags_NoScrollbar); store_window_size(); store_window_position(); display_image(image_texture_id, image_size, need_to_fit); ImGui::End(); } else { _size.reset(); _is_hovered = false; } } void View::store_window_size() { const auto size = ImGui::GetContentRegionAvail(); if (size.x &gt;= 1.f &amp;&amp; size.y &gt;= 1.f) { _size.emplace( static_cast&lt;ImageSize::DataType&gt;(size.x), static_cast&lt;ImageSize::DataType&gt;(size.y)); } else { _size.reset(); } } void View::store_window_position() { _position = ImGui::GetCursorScreenPos(); } void View::display_image(ImTextureID image_texture_id, ImageSize image_size, bool need_to_fit) { if (_size.has_value()) { const auto fitted_image_size = need_to_fit ? ImageSizeU::fit_into(*_size, image_size) : static_cast&lt;ImageSizeT&lt;float&gt;&gt;(*_size); ImGuiExtras::image_centered(image_texture_id, {fitted_image_size.width(), fitted_image_size.height()}); _is_hovered = ImGui::IsItemHovered(); } else { _is_hovered = false; } } Copy "},{"title":"Going further​","type":1,"pageTitle":"Write small functions","url":"lessons/write-small-functions/#going-further","content":"Going Further Tony Van Eerd, SOLID, Revisited (1h30) "}]