"use strict";(self.webpackChunkteaching_toolbox_website_generator=self.webpackChunkteaching_toolbox_website_generator||[]).push([[8803],{4137:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(n),h=r,y=d["".concat(c,".").concat(h)]||d[h]||u[h]||o;return n?a.createElement(y,i(i({ref:t},p),{},{components:n})):a.createElement(y,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9561:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return d}});var a=n(7462),r=n(3366),o=(n(7294),n(4137)),i=["components"],s={title:"Dependencies",benefit:5,easiness:1,order:3,tags:["Architecture"]},c=void 0,l={unversionedId:"lessons/dependencies",id:"lessons/dependencies",title:"Dependencies",description:"Managing dependencies between the different parts of your application is probably the most difficult challenge as your codebase grows.",source:"@site/../../content/lessons/dependencies.md",sourceDirName:"lessons",slug:"/lessons/dependencies",permalink:"/Learn--Cpp-And-Dev-Practices/lessons/dependencies",tags:[{label:"Architecture",permalink:"/Learn--Cpp-And-Dev-Practices/tags/architecture"}],version:"current",frontMatter:{title:"Dependencies",benefit:5,easiness:1,order:3,tags:["Architecture"]},sidebar:"lessons",previous:{title:"Type design",permalink:"/Learn--Cpp-And-Dev-Practices/lessons/type-design"},next:{title:"Single Source of Truth",permalink:"/Learn--Cpp-And-Dev-Practices/lessons/single-source-of-truth"}},p=[{value:"The Singleton attempt",id:"the-singleton-attempt",children:[],level:2},{value:"The best practices",id:"the-best-practices",children:[{value:"Dependency Injection",id:"dependency-injection",children:[{value:"About storing a reference to a dependency",id:"about-storing-a-reference-to-a-dependency",children:[],level:4},{value:"When you have no choice but to store the dependency",id:"when-you-have-no-choice-but-to-store-the-dependency",children:[],level:4}],level:3},{value:"Dependency Inversion (the D of SOLID)",id:"dependency-inversion-the-d-of-solid",children:[],level:3}],level:2},{value:"Concepts vs Interfaces",id:"concepts-vs-interfaces",children:[],level:2},{value:"To go further",id:"to-go-further",children:[],level:2}],u={toc:p};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Managing dependencies between the different parts of your application is probably the most difficult challenge as your codebase grows."),(0,o.kt)("h2",{id:"the-singleton-attempt"},"The Singleton attempt"),(0,o.kt)("p",null,"One tempting solution is to resort to the ",(0,o.kt)("em",{parentName:"p"},"Singleton")," (anti-)pattern. In its simplest form it consists in making your class static ",(0,o.kt)("sup",{parentName:"p",id:"fnref-1"},(0,o.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," so that anyone can access it from anywhere. It has the advantage that you don't need to pass an instance around (which would probably require you to modify the signature of quite a few fonctions to pass the instance to the parts that need it). ",(0,o.kt)("strong",{parentName:"p"},"This makes the Singleton a really good solution ",(0,o.kt)("em",{parentName:"strong"},"in the short term"),".")),(0,o.kt)("p",null,"But the Singleton can end up causing a few problems, hence why most people have stopped using it :"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"It prevents you from having multiple instances of the same class"),". Obviously you are a reasonable person and you use a Singleton only for classes that you need one single instance of. . . But you might realize later that actually you need to have multiple instancies.\nI have a few examples from my personal experience : ",(0,o.kt)("em",{parentName:"li"},"an history")," seems like it is unique across the application, until you realize that having separate histories for separate systems is a useful feature. And the argument to rule them all : what if you want to have multiple instances of your application in parallel ? Then you can't have any static data because it would be shared accross the instancies of your application. For example think of a workspace in a drawing application : you might want to have multiple drawings open at once, each with it's own layer system, history, etc."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"It reduces testability")," : each class that depends on a static class cannot be used outside of the application. This is a big problem for testing (and also for reusing your code !). When testing we usually like to create fake instancies of the dependencies of a class to test that class. For example if you depend on a server, it is nice to make your tests with a mock server (for example that returns a dummy answer when you make a request, whithout even making a web call to a service) rather that the production one ! It prevents breaking things or even relying on having a server running. Also you can test different scenarios \u2013 like the server beeing down \u2013 whithout having to shut down your actual server !\nThis is also why you should depend on interfaces and never on concrete classes. If you depend on an ",(0,o.kt)("inlineCode",{parentName:"li"},"IServer")," you can then have different test implementations : ",(0,o.kt)("inlineCode",{parentName:"li"},"MockServerRunning"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"MockServerDown"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"MockServerLaggy")," etc."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"It hides dependencies"),". Even though it is a pain to write each dependency explicitly in the signature of functions, later down the road you will be happy to be able to see at a glance what is required for a given function (when refactoring for example). It will also be easier to reuse the code later in other projects if the only dependencies are at the function boundary (aka in the signature).")),(0,o.kt)("h2",{id:"the-best-practices"},"The best practices"),(0,o.kt)("h3",{id:"dependency-injection"},"Dependency Injection"),(0,o.kt)("p",null,"Yes, you should receive as parameters all the classes / systems that you depend on. Storing them as members isn't the cleanest either in my opinion (this can be qualified though) ; ",(0,o.kt)("del",{parentName:"p"},"I would tend to only store a reference to a class if there is a very strong coupling between the two (like a ",(0,o.kt)("inlineCode",{parentName:"del"},"CameraController")," and the corresponding ",(0,o.kt)("inlineCode",{parentName:"del"},"Camera"),")")," (EDIT : I would ",(0,o.kt)("strong",{parentName:"p"},"almost never")," store references because it makes copying and assigning pretty troublesome / impossible)."),(0,o.kt)("p",null,"You should always send references as parameters to each function that needs them : it prevents you from introducing extra member variables, and makes it clearer which parts of your class actually need or act upon a dependency."),(0,o.kt)("p",null,"If you end up with too many arguments, maybe grouping them in a struct can be a good idea. This should be considered carefully though because it can lead to introducing unnecessary dependencies (if a class X needs 4 out of the 5 classes packaged in a struct Y, it can be tempting to make X depend on Y, although it will grab one unnecessary dependency, which is ",(0,o.kt)("em",{parentName:"p"},"bad"),")."),(0,o.kt)("h4",{id:"about-storing-a-reference-to-a-dependency"},"About storing a reference to a dependency"),(0,o.kt)("p",null,"Storing ",(0,o.kt)("em",{parentName:"p"},"a reference")," is a problem because it makes your type more complex than it needs to be. I realized that after a 1 hour debugging session filled with cryptic template error messages.\nHaving a reference in your type will make it ",(0,o.kt)("strong",{parentName:"p"},"non-copy-assignable")," ! That is because when trying to assign to a refence, you are actually assigning to the object behind the reference ! You cannot modify where the reference points to after its creation !"),(0,o.kt)("p",null,"Let's have an example :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class MyClass {\npublic:\n    // Constructor\n    MyClass(const MyDependency& my_dependency) \n        : _my_dependency{my_dependency} // OK : initializes the reference to point to my_dependency\n    {}\n    // Copy Constructor\n    MyClass(const MyClass& o)\n        : _my_dependency{o._my_dependency} // OK : initializes the reference to point to o.my_dependency\n    {}\n    // Copy Assignment operator\n    MyClass& operator=(const MyClass& o)\n    {\n        _my_dependency = o._my_dependency; // Bad ! This doesn't change where the reference is pointing to, but instead tries to modify the object that the reference points to ! Here this is a compile error because _my_dependency is a const&, but if it was not const, that would be a silent bug modifying the object pointed to by _my_dependency!!!\n        return *this;\n    }\nprivate:\n    const MyDependency& _my_dependency;\n};\n")),(0,o.kt)("p",null,"Here is a nice article about problems around references by Herb Sutter : ",(0,o.kt)("a",{parentName:"p",href:"https://herbsutter.com/2020/02/"},"https://herbsutter.com/2020/02/")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Also")," when you store a reference or a pointer, you must make sure that the pointed object outlives the class where the reference is stored ; otherwise you will get a dangling reference or pointer !\nFor example if your dependency lives in a ",(0,o.kt)("inlineCode",{parentName:"p"},"std::vector"),", and the vector gets resized at some point, all the references to elements of that vector get invalidated ! If you stored one such reference, you are in trouble ! On the contrary if you pass a reference each frame, you will not notice the change of adress in memory at all."),(0,o.kt)("h4",{id:"when-you-have-no-choice-but-to-store-the-dependency"},"When you have no choice but to store the dependency"),(0,o.kt)("p",null,"An interesting exception to the ",(0,o.kt)("em",{parentName:"p"},"do not store your dependencies")," rule is if you need your dependency in the destructor of your class (or in an operator like ",(0,o.kt)("inlineCode",{parentName:"p"},"+="),") : in those cases, you cannot pass any arguments ! Therefore you have no other choice but to store the dependency inside the class (or have it global but that would be even worse !)"),(0,o.kt)("p",null,"In such cases",(0,o.kt)("sup",{parentName:"p",id:"fnref-2"},(0,o.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),", you can use a ",(0,o.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper"},(0,o.kt)("inlineCode",{parentName:"a"},"std::reference_wrapper")),": it will act like a reference, but still be copyable."),(0,o.kt)("h3",{id:"dependency-inversion-the-d-of-solid"},"Dependency Inversion (the D of SOLID)"),(0,o.kt)("p",null,"The interfaces should be owned by the high level that uses it, not by the low level that implements it."),(0,o.kt)("h2",{id:"concepts-vs-interfaces"},"Concepts vs Interfaces"),(0,o.kt)("p",null,"Concepts are better than interfaces because they can also require the existance of free functions, not only methods."),(0,o.kt)("p",null,"For example if you want to require that each shape is drawable, with an interface it would require that ",(0,o.kt)("inlineCode",{parentName:"p"},"draw()")," be a method of each ",(0,o.kt)("inlineCode",{parentName:"p"},"Shape")," class. With concepts you can require that a free function ",(0,o.kt)("inlineCode",{parentName:"p"},"draw(Shape const auto& shape)")," exists for each type following the ",(0,o.kt)("inlineCode",{parentName:"p"},"Shape")," concept. And free functions are great for many reasons ! (Single Responsibility Principle, Open-Close Principle, etc. See ",(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=WLDT1lDOsb4"},"Free your functions"),")"),(0,o.kt)("h2",{id:"to-go-further"},"To go further"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=K5c7uvWe_hw"},"About the Singleton and alternatives to it")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=Ntraj80qN2k"},"About SOLID by Klaus Iglberger")),(0,o.kt)("div",{className:"footnotes"},(0,o.kt)("hr",{parentName:"div"}),(0,o.kt)("ol",{parentName:"div"},(0,o.kt)("li",{parentName:"ol",id:"fn-1"},"Or rather have a static instance available through a ",(0,o.kt)("inlineCode",{parentName:"li"},"MyClass::get()")," method, because it gives you control over the instanciation and destruction order, which is important when you have dependencies between your singletons, and when you use multithreading.",(0,o.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,o.kt)("li",{parentName:"ol",id:"fn-2"},"I met such a case when creating wrapper classes for Vulkan resources: they need a reference to the device to be destructed, so I had to store a handle to the device in each wrapper class.",(0,o.kt)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")))))}d.isMDXComponent=!0}}]);