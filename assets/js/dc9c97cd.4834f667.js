"use strict";(self.webpackChunklearn_cpp_and_dev_practices=self.webpackChunklearn_cpp_and_dev_practices||[]).push([[2482],{1985:function(e){e.exports=JSON.parse('{"name":"C++","permalink":"/Learn--Cpp-And-Dev-Practices/docs/tags/c","docs":[{"id":"lessons/if-defined","title":"#if defined()","description":"#if defined(SOMETHING) offers more flexibility than #ifdef SOMETHING.","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/if-defined"},{"id":"lessons/assert","title":"assert and static_assert","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/assert"},{"id":"lessons/auto","title":"auto","description":"Most of the time the type of a variable is obvious and a type declaration would be redundant. In such cases you can use auto instead :","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/auto"},{"id":"lessons/against-nested-namespaces","title":"Avoid nested namespaces","description":"https://youtu.be/xu7q8dGvuwk?t=1198","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/against-nested-namespaces"},{"id":"lessons/cpp-casts","title":"C++ casts","description":"5 min","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/cpp-casts"},{"id":"lessons/cmake","title":"CMake","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/cmake"},{"id":"lessons/const","title":"const","description":"Bonus trick","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/const"},{"id":"lessons/deleted-functions","title":"Deleted functions","description":"You can delete functions to prevent them from beeing used. This is mostly used to prevent a type from being copied ; for example std::sharedptr.","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/deleted-functions"},{"id":"lessons/designated_initializers","title":"Designated Initializers","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/designated_initializers"},{"id":"lessons/enums","title":"Enums","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/enums"},{"id":"lessons/exceptions","title":"Exceptions","description":"Despite their bad reputations, they are actually pretty good and you should consider using them.","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/exceptions"},{"id":"lessons/friend","title":"friend","description":"There are *very few* good reasons to use `friend`.","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/friend"},{"id":"lessons/lambda","title":"Lambda functions","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/lambda"},{"id":"lessons/linked-list","title":"Linked lists","description":"Linked lists are rarely usefull. All the theoretical advantages in insertion time and what not are actually murdered by the awfull cache coherency that make them actually very slow.","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/linked-list"},{"id":"lessons/move-semantics","title":"Move semantics","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/move-semantics"},{"id":"lessons/multithreading","title":"Multithreading","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/multithreading"},{"id":"lessons/pointer-vs-reference","title":"Pointers vs References","description":"Pointers can be null","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/pointer-vs-reference"},{"id":"lessons/range-based-for-loop","title":"Range-based for loop","description":"It helps you express your intent more clearly. If you want to go over each element once (which the case of most for loops) you can write :","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/range-based-for-loop"},{"id":"lessons/rule-of-5","title":"Rule of 5","description":"If yo have to do that, try to limit its scope. You most likely have only one member of your class that requires the destructor / move. Then, move that member into its own class that implements the rule of 5, and in your main class use that wrapper class and let the compiler generate the destructor / move / copy. It will prevent you from forgetting to copy a member in your copy / move, or something silly of that kind. Most classes shuldn\'t have complex destruction behaviour, and those wo do should be kept to a minimal size.","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/rule-of-5"},{"id":"lessons/smart-pointers","title":"Smart Pointers","description":"No naked new : this doesn\'t mean no dynamic allocations, it just means they should always be done through a smart pointer or a container.","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/smart-pointers"},{"id":"lessons/stack-vs-heap","title":"Stack vs Heap","description":"Good Reasons to use the heap :","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/stack-vs-heap"},{"id":"lessons/optional","title":"std::optional","description":"https://youtu.be/ojZbFIQSdl8?t=1056","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/optional"},{"id":"lessons/variant","title":"std::variant","description":"https://youtu.be/ojZbFIQSdl8?t=869","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/variant"},{"id":"lessons/vector","title":"std::vector","description":"Despite its awfull name, this is the most amazing container ever !","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/vector"},{"id":"lessons/stl-algorithms","title":"STL algorithms","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/stl-algorithms"},{"id":"lessons/string-and-string-view","title":"string and string_view","description":"`stringview` is compatible with both `string` and `const char*`. You don\'t need to do conversions or call .cstr().","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/string-and-string-view"},{"id":"lessons/trailing-return-type","title":"Trailing return type","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/docs/lessons/trailing-return-type"}],"allTagsPath":"/Learn--Cpp-And-Dev-Practices/docs/tags"}')}}]);