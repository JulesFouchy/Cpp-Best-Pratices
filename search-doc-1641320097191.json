[{"title":"Introduction","type":0,"sectionRef":"#","url":"assignment","content":"","keywords":""},{"title":"\"Passe-moi le code !\"​","type":1,"pageTitle":"Introduction","url":"assignment#passe-moi-le-code-","content":"Que ce soit tes sources ou ton Wi-Fi, stp passe-moi le code ! – MC-Risson In order to evaluate you, all I need is to see some code you wrote in order for me to tell which lessons you mastered. This means that the exact project you will be working on is up to you. I will provide a suggestion of a small project with guided steps, but you can choose to work on your own project instead. The main difference will be that I won't be able to provide you with guided steps for your own projects, but this also means that you will learn a ton more by doing it! You might also be more motivated to work on something you chose and care about. "},{"title":"Submitting your work​","type":1,"pageTitle":"Introduction","url":"assignment#submitting-your-work","content":"I will be looking at your code regularly to give you feedback and start checking the lessons that you are learning. In order for me to do so, all of you must publish you work on a public Git repository (which is good practice anyways, and will be the number one lesson I will be looking at). You can use GitHub, GitLab or whatever you are used to using. Just send me a link to the relevant repository now (or as soon as you start working on the project). Also, there are some lessons that I won't be able, from looking at your code, to tell if you have read them, like Master your IDE. So it would be nice if you kept a little ReadMe of all the lessons you have read. You can also use it for yourself: for example you can take notes of the things you learned in the lesson and really don't want to forget1, note the points that you didn't quite get, the ones you disagree with, etc. "},{"title":"Time investment​","type":1,"pageTitle":"Introduction","url":"assignment#time-investment","content":"In terms of invested time I won't ask you more than can fit during the class sessions, i.e. 24 hours in total this semester. This means that hopefully you won't have to work (too much) outside of class on your spare time. Please note that I will only be evaluating the quality of your code, not the state of the end product. This means that it doesn't matter if you don't have time to finish the project you set out to do! Your grade will be solely based on the lessons you successfully applied in the project. So no worries please 😎. "},{"title":"Option#1: Rolling your own project​","type":1,"pageTitle":"Introduction","url":"assignment#option1-rolling-your-own-project","content":"I would highly encourage you to do so if you are really interested in programming. You will definitely learn a ton by doing so, and produce something that you will be proud of. If you choose to do so it might be a good idea to share your plans with me so that we can discuss them, give you some feedback or suggestions, and try to estimate the time it will take you. Note that you can still embark on a huge project if you so desire because it doesn't matter if you don't finish it for the end of the semester (see Time investment). For this project you can work in groups. Simply remember that the more you are on a project, the harder it is to coordinate and produce a cohesive codebase. But if you think that a collaboration would be beneficial, then please go ahead! I also think that it only makes sense to team up with people who have roughly the same level as you. This way you will be able to help each other out and discuss ideas on equal footing. If you are looking for someone very good to help you, you can always ask your comrades or me! But working on the same project wouldn't be beneficial I believe because you won't be advancing at the same pace and/or having the same ambitions. (I might be wrong though and we can discuss that). If you choose Option#1, you don't need to care about the other pages of the Assignment section. "},{"title":"Project ideas​","type":1,"pageTitle":"Introduction","url":"assignment#project-ideas","content":"If you are looking for inspiration I can suggest a few ideas that I would personally love working on: Cool: I am currently working on a C++ framework called Cool where we do a lot of image-related work. If you are interested in joining the adventure, there is definitely a place for you! "},{"title":"Option#2: Following the guided project​","type":1,"pageTitle":"Introduction","url":"assignment#option2-following-the-guided-project","content":"This option will be easier to follow and shouldn't require as much time investment. The project will consist in making a few little games: hangman, noughts and crosses, etc.. It makes sense to choose this option if you don't want to have to organize and plan a project by yourself. Here you will be able to focus entirely on the micro-level programming tasks like &quot;let's get a string from the user&quot;, &quot;let's check if this word contains this letter&quot; and so on. The other pages of this section will guide you through this project step by step. I believe it is better if you work alone on this project. (But we can discuss that if you think it will be beneficial for you to team up with someone). This is a great learning practice. See The Pragmatic Programer, Chapter 3, Section Engineering Daybooks.↩ "},{"title":"Adding a menu","type":0,"sectionRef":"#","url":"assignment/adding-a-menu","content":"","keywords":""},{"title":"Skeleton​","type":1,"pageTitle":"Adding a menu","url":"assignment/adding-a-menu#skeleton","content":"Here is a skeleton to help you: int main() { bool quit = false; while (!quit) { show_the_list_of_commands(); // TODO: implement this function const auto command = get_input_from_user&lt;char&gt;(); // TODO: handle the different possible values of command with a switch // NB: don't forget to handle the case of an invalid command! } } Copy Commit "},{"title":"Bonus​","type":1,"pageTitle":"Adding a menu","url":"assignment/adding-a-menu#bonus","content":"Something that is a little annoying is that we have to make sure we don't mess up between what we say in show_the_list_of_commands() and what we actually implement in our switch. Imagine we want to change the command for a given game: we need to change it in two places, that's bad!1 Can you think of a way to make the code more robust and easier to change? Hint You could define a Game struct that would contain the name of the game as a string and the function you need to call to start the game. Then you can associate a distinct command to each game by storing the game in a map (or an array if you only plan to use numbers: the index of the game will correspond to its command). Commit "},{"title":"Refactoring​","type":1,"pageTitle":"Adding a menu","url":"assignment/adding-a-menu#refactoring","content":"As usual, move the code to its own file in order to clean up main.cpp. Commit We are duplicating knowledge and violating the DRY principle (see DRY: Don't repeat yourself)↩ "},{"title":"Adding tests","type":0,"sectionRef":"#","url":"assignment/adding-tests","content":"Adding tests We will go back to our Hangman game and add a few tests. Tests are very important and a huge part of the job of every developer. To learn why tests are so great and how to write them, first read the lesson. TODO SHOW HOW TO TEST SOME SIMPLE FUNCTIONS The most interesting tests will be for the logging functions like show_word_to_guess_with_missing_letters(). How can we know what has been outputed to std::cout? It is tricky and even if there was a way, this is not the right approach! Our function show_word_to_guess_with_missing_letters() is inherently hard to test because it has side-effects! If we tweak our function and move the side-effect outside of it, it will become a pure function that is much easier to test. It will also become more general, and easier to reason about! Many good reasons to get rid of the side-effects! tip You will often find that trying to design a function to make it testable also forces you to design a better function in the first place 😉 In its previous version show_word_to_guess_with_missing_letters() had two reasons to change: if we wanted to change how the string is formated, and if we wanted to change the way we output it to the user! It didn't respect the Single Responsibility Principle! Now we will split this into two simpler chunks: std::string format_word_to_guess_with_missing_letters(const std::string&amp; word, const std::vector&lt;bool&gt;&amp; letters_guessed) { // TODO: return the string instead of outputing it to std::cout } Copy and the act of outputting to std::cout is already so simple that we can use it directly in the main code: pick_a_word_to_guess(); while (player_is_alive() &amp;&amp; !player_has_won()) { show_number_of_lives(); std::cout &lt;&lt; format_word_to_guess_with_missing_letters(word_to_guess, letters_guessed); // ... Copy It might feel silly to add tests to a code that we already know to work. And even though it kinda is, there is still a lot of benefits to writing tests afterwards: common misconception: the main goal of tests is not to prove that the code you just wrote is correct (we trust you on that, even though tests can help you writing your code), they are mainly here to make sure that whenever anyone changes the code, it remains correct! (But if you can write the tests as you write the code it is even better because they will help you write and debug your code, and you are less likely to forget to test an edge case) And since we will modify our Hangman in the next section, now is a good time to add tests to it.","keywords":""},{"title":"connect-4","type":0,"sectionRef":"#","url":"assignment/connect-4","content":"connect-4","keywords":""},{"title":"An AI for Hangman","type":0,"sectionRef":"#","url":"assignment/ai-for-hangman","content":"An AI for Hangman Now we want to write a program that plays Hangman by itself. You will notice that at the moment our play_hangman() function is very opaque and you cannot easily change the way the programm receives guesses from the user. This is a small design flaw that we will fix through Dependency Injection (which is a fancy way of saying that we will add a parameter to our function): void play_hangman(std::function&lt;char()&gt; get_next_guess) { // TODO: replace get_input_from_user&lt;char&gt;() with get_next_guess() } Copy","keywords":""},{"title":"Going further","type":0,"sectionRef":"#","url":"assignment/going-further","content":"Going further If you finished all the tutorials and still want to keep coding, now is a good time to decide by yourself what you want to add next to your project 😁 AIs for the other games? More games? Highscores and stats for the games? It is up to you! You could also come back to the code you have already written and try to improve it. Or just read lessons until you learn something new that you could apply to the code you have. There won't be any guided steps, but you can discuss with me at any time 😁","keywords":""},{"title":"Guess the number","type":0,"sectionRef":"#","url":"assignment/guess-the-number","content":"","keywords":""},{"title":"The building blocks​","type":1,"pageTitle":"Guess the number","url":"assignment/guess-the-number#the-building-blocks","content":"So, what do we need to code for this game? pick a random numberget an input from the usercompare the input to the number we picked, and display a message accordinglyrepeat until the user finds the correct number We will code each of these features one by one, and we will assemble them at the end. "},{"title":"Picking a random number​","type":1,"pageTitle":"Guess the number","url":"assignment/guess-the-number#picking-a-random-number","content":"Actually this is a bit of an annoying topic in C++, because C++ wants to be very generic and fit every use case. You can read the lesson on random number generators or just copy this function: #include &lt;random&gt; /// Returns a random int between min (included) and max (included) int rand(int min, int max) { static std::default_random_engine generator{std::random_device{}()}; std::uniform_int_distribution&lt;int&gt; distribution{min, max}; return distribution(generator); } Copy Commit "},{"title":"Getting an input from the user​","type":1,"pageTitle":"Guess the number","url":"assignment/guess-the-number#getting-an-input-from-the-user","content":"You can use std::cin for that. I recommend to wrap that bit of code inside a function, because it will make the usage more convenient afterwards: int get_int_from_user() { // TODO ;) Use std::cin to get an int, and then return it } Copy PS: did you think of what happens when the user tries to input something that is not a number? Here is a link that can help you. (NB: now you might start to understand why we wrap this code in a get_int_from_user() function: the code is not trivial so we want to encapsulate it. You can also read Write small functions.) Commit "},{"title":"The game​","type":1,"pageTitle":"Guess the number","url":"assignment/guess-the-number#the-game","content":"We will now finish our game by implementing the last two steps! void play_guess_the_number() { // TODO } Copy First you need to pick a random numberThen you need a loop that asks the user for a number, until he guesses right. For the loop you can do something like bool finished = false; while (!finished) { // Ask for a number // If it is the correct one then set finished to true // Else give a hint to the user (&quot;Greater&quot; or &quot;Smaller&quot;) } Copy Commit "},{"title":"Refactoring​","type":1,"pageTitle":"Guess the number","url":"assignment/guess-the-number#refactoring","content":"Now that we are done with that game we will move the code into its own file, so that main.cpp is now clean again and we can start coding our next game! tip It is a good practice to first code as you want, where you want, and get something working. You can worry about cleaning up in a second step. (Read Make it work, then make it good) Think of what needs to go in the header (.hpp), and what belongs to the source file (.cpp). Tip: try to put as little things as possible in the header, because we want to keep things private as much as possible. Your main file should now look like: #include &quot;play_guess_the_number.h&quot; int main() { play_guess_the_number(); } Copy Commit "},{"title":"Noughts and Crosses","type":0,"sectionRef":"#","url":"assignment/noughts-and-crosses","content":"","keywords":""},{"title":"Adding the library​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses#adding-the-library","content":"First you will need to add the library to your project. This might be a great time to read the lessons on CMake and Git submodules. Also the examples for the library might help you (in order to find them, browse the GitHub of the library). Commit "},{"title":"First steps​","type":1,"pageTitle":"Noughts and Crosses","url":"assignment/noughts-and-crosses#first-steps","content":"tip I encourage you to first try to code without reading the guided steps that follow! Think of the different functions that you need to write, and try to implement them! Only when you are stuck are you allowed to keep reading 😉 And read only enough to get unstuck! Then try to keep coding by yourself 😁 (until you are stuck again) In order to get familiar with the library we will start by trying to do some very simple things: First create a windowThen display a square in that window Again, the library provides all the examples you will need to do that 😉 "},{"title":"Setting up a project","type":0,"sectionRef":"#","url":"assignment/project-setup","content":"","keywords":""},{"title":"Git​","type":1,"pageTitle":"Setting up a project","url":"assignment/project-setup#git","content":"First things first, let's create a Git repo. If you are not used to using Git, read the associated lesson. I also created a repo that you will be able to use as a reference / solution as you work on the project. I will regularly link to commits that correspond to the current exercise, and you can also check out the commit history. NB: in my solution there are a lot of comments that explain why I do things in a certain way. They are not good examples of comments that you should put in your code ; they are only here to help you learn C++. For example these comments shouldn't appear in actual code: static constexpr int MIN = 0; // `static constexpr` is the &quot;proper&quot; way of declaring constants known at compile time static constexpr int MAX = 100; // It is as efficient as `#define` but has the benefit of working like a normal C++ variable: it has a type, etc. Copy NB: my solutions will not always be the best, partly to keep them simple, partly to leave you room to think and improve the code I give you 😉 (and partly because I am not an omniscient programmer and there might be things that I am simply not aware of). We will come back to some of the solutions later to improve them. "},{"title":"Project template​","type":1,"pageTitle":"Setting up a project","url":"assignment/project-setup#project-template","content":"I would recommend you use this template. It is a minimalist C++ project that uses CMake. It also sets up a few tools that will be useful to you. Read its readme to learn how to build it! (NB: I don't recommend to use the dev container for this project because we will do some graphics stuff later on). "},{"title":"Introduction","type":0,"sectionRef":"#","url":"lessons","content":"","keywords":""},{"title":"Forewords​","type":1,"pageTitle":"Introduction","url":"lessons#forewords","content":"Welcome to this class! We will only assume some beginner-level experience in programming with C++ or a similar language like C#, Java, C, Javascript, etc., and will guide you from your current level to being a solid programmer who loves coding and creates amazing software 🥳. "},{"title":"Goals​","type":1,"pageTitle":"Introduction","url":"lessons#goals","content":"What are the properties of good code? Correctness is certainly number one. And maintainability comes second, a.k.a. how easy your code is to change while preserving its correctness. Performance comes third, since it doesn't matter how fast you are if you are going in the wrong direction 😛. GOAL In this class we will focus on writing Clean Code, a.k.a. code that is correct and maintainable. Clean code is an essential concern when you start building larger projects that are meant to last for years. Anyone should be able to pick up your code and – within a reasonable time frame – understand what it does, what its role inside the project is, and how to modify it. Clean code is both a concern at the architectural level (organisation between modules and classes) and at the granular level (organisation inside a given class or function). We will see basic coding habits that make your code more expressive, general principles that help you organize your code, a few amazing design patterns, and we will get into the habit of using meaningful names and writing documentation and tests. We will also discover the amazing tools that are available to make our job easier and way more enjoyable. NOT ALL C++ Although this class makes use of C++, most of its content will be applicable to any language and any kind of programming project. "},{"title":"How to​","type":1,"pageTitle":"Introduction","url":"lessons#how-to","content":"I will not be giving lectures. Instead I will let you all move along with the lessons and exercises at your own pace. I will be here to answer questions, and occasionally talk to the whole class about very important things that I want to highlight. I believe this is the best way for you to learn, for practicing is when the actual learning happens. Moreover, giving lectures would imply that you are all at the same point in your learning journey and are all ready to learn the same things, which is definitely never true, not for any single group of students larger than 2. These lessons are not meant to be read one after the other. Instead look at the list of lessons and pick one (or a few) that seem interesting to you; read the lessons and then try to apply them in your exercises or projects. Once you mastered them, repeat. Note that the lessons are sorted by order of importance so it makes sense to somewhat follow the order, even though this is not a strict one. "},{"title":"Evaluation​","type":1,"pageTitle":"Introduction","url":"lessons#evaluation","content":"The evaluation is skill based: you will find a long list of lessons that I deem important, and you will be graded on how much you learn during this semester. Check out the assignment section to learn more about what you will have to submit. "},{"title":"Rationale​","type":1,"pageTitle":"Introduction","url":"lessons#rationale","content":"I must acknowledge that you all have very different levels coming into this class, so I must give everyone the opportunity to make progress at their own pace. This means that the evaluation is not absolute, but relative to your level at the beginning of the semester. This will require a self-evaluation that I will then use to know how much progress you made and reward that. The extra investment will also be rewarded. I expect that the dedicated classroom hours will be enough for you to get meaningful value out of this class (and a good grade), but if you want or need to invest more time I will make sure to take that into account too. My hope is that you won't spend too much time working outside of the class if this is not something you wish to do. You will have a great visibility on your current grade as you progress in the semester and you will always have the possibility to submit extra work to improve it if you wish. "},{"title":"Give me feedback​","type":1,"pageTitle":"Introduction","url":"lessons#give-me-feedback","content":"I tried my best to deliver a great learning experience to you. I am still a novice teacher though (and even if I were experienced, one never runs out of things to learn anyways). So your feedback is more than welcome and I will happily improve my classes with your help! To do so, feel free to reach out to me directly or raise an issue on GitHub. "},{"title":"Hangman","type":0,"sectionRef":"#","url":"assignment/hangman","content":"","keywords":""},{"title":"The building blocks​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#the-building-blocks","content":"We will first write the global logic of our game, and will then implement each function one by one: pick_a_word_to_guess(); while (player_is_alive() &amp;&amp; !player_has_won()) { show_number_of_lives(); show_word_to_guess_with_missing_letters(); const auto guess = get_char_from_user(); if (word_to_guess_contains(guess)) { mark_as_guessed(guess); } else { remove_one_life(); } } if (player_has_won()) { show_congrats_message(); } else { show_defeat_message(); } Copy It should look like that in the end (even though we will probably have to modify it a bit as we write our code) "},{"title":"Picking a random word​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#picking-a-random-word","content":"You might be able to reuse what we did for the last game where we needed a random int. If you do so, you will need to move the rand() code to it's own file so that it can be included both in Guess the Number and Hangman. You can use a hardcoded list of words like: #include &lt;array&gt; const char* pick_a_random_word() { static constexpr std::array words = { &quot;code&quot;, &quot;crous&quot;, &quot;imac&quot;, &quot;opengl&quot;, }; // TODO: return a random element from the array } Copy Commit   NB: you might also need to turn rand() into a template in order to be able to use it with other types of integers like size_t and uint32_t. Commit "},{"title":"Getting an input from the user​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#getting-an-input-from-the-user","content":"The code is gonna be very similar to what we did in the last game, except that we want a char instead of an int. It might be time to generalize that code with a template! First, let's move get_int_from_user() into its own get_input_from_user.h file. Commit   Then we can turn it into a template, and rename it because it is not tied to integers anymore: /// Blocks until the user inputs something of type T in the console template&lt;typename T&gt; T get_input_from_user() { // TODO: replace int with T } Copy Commit "},{"title":"The state of the game​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#the-state-of-the-game","content":"Now we will ask a difficult and fondamental question! Many functions we wrote in our pseudo-code need to have access to some state. For example show_number_of_lives() needs to know the number of lives, show_word_to_guess_with_holes() needs to know the word to guess and the letters that have already be found, and so on. So, how are we gonna give our functions access to this state? tip This is a complex question and there is no one true answer, so feel free to ponder and find your own 🥰 One answer might be that we will make a class which will have all the state as member variables, and that our show_number_of_lives() will be a member function. One problem with that approach is that now show_number_of_lives() also has access to variables it doesn't need like the word to guess and the letters that have already be found. It is as if we wrote show_number_of_lives(int number_of_lives, const std::string&amp; word_to_guess, const std::vector&lt;char&gt;&amp; letters_that_have_been_found), giving three parameters to our function even though it only needs one. The solution that I suggest is that we write all of them as free functions, taking only the parameters they need. We will then have our state in a struct and only pass the required parts of our state to the different functions. (See Prefer free functions) So, what do we put in our state? Well, I guess we will see as we implement each function 😉 "},{"title":"show_number_of_lives()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#show_number_of_lives","content":"This function only needs the number of lives, so its signature will be void show_number_of_lives(int number_of_lives) { // TODO } Copy Commit "},{"title":"player_is_alive()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#player_is_alive","content":"The signature of this function will be bool player_is_alive(int number_of_lives) { // TODO } Copy Commit "},{"title":"player_has_won()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#player_has_won","content":"This one is a bit tricky ; we need to decide how we are gonna store the letters that the user has guessed in order to know if has won. We have many choices of implementation. We can trade off simplicity of the code for performance if we want to. But since the words are always gonna be small (less than 1000 characters, obviously) performance should not be a concern and we are gonna aim for the simplest code possible. I thing of vector of bools will work great, indicating for each letter of the word if it has been found. bool player_has_won(const std::vector&lt;bool&gt;&amp; letters_guessed) { // TODO } Copy We need to know if the vector contains at least one false. You might be tempted to use a loop, but you can also use an algorithm from the standard library and do this in one line! Go search on the Internet how you can do that 😉 NB: several algorithms can be used to achieve this result and it doesn't really matter which one you pick. Commit "},{"title":"show_word_to_guess_with_missing_letters()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#show_word_to_guess_with_missing_letters","content":"We need to output something like c _ _ e void show_word_to_guess_with_missing_letters(const std::string&amp; word, const std::vector&lt;bool&gt;&amp; letters_guessed) { // TODO } Copy Commit "},{"title":"word_contains()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#word_contains","content":"bool word_contains(char letter, std::string_view word) { // TODO } Copy What is string_view? It is a new type from C++17. It is a non-owning reference to either a const char* or a std::string. It has many advantages: providing the same API as std::string for const char* without having to pay the cost of constructing a std::string, working with const char* and std::string as if they were the same type, etc. Just remember that it is non-owning, like a reference: it is great for passing parameters around, but if you need to store it as a long-lasting variable you probably still need to use a std::string. (Read std::string and std::string_view) (NB: there might be a one-liner solution available in the standard library! Go search for it 😉) Commit "},{"title":"mark_as_guessed()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#mark_as_guessed","content":"void mark_as_guessed(char guessed_letter, std::vector&lt;bool&gt;&amp; letters_guessed, std::string_view word_to_guess) { // TODO } Copy Again, try to use an algorithm instead of a raw loop. Commit "},{"title":"remove_one_life()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#remove_one_life","content":"void remove_one_life(int&amp; lives_count) { // TODO } Copy Commit "},{"title":"show_congrats_message()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#show_congrats_message","content":"void show_congrats_message(std::string_view word_to_guess) { // TODO } Copy Commit "},{"title":"show_defeat_message()​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#show_defeat_message","content":"void show_defeat_message(std::string_view word_to_guess) { // TODO } Copy Commit "},{"title":"Assembling it all​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#assembling-it-all","content":"Now we can go back to our pseudo-code and implement it. The final code might be a bit different because we did not consider the parameters we had to pass to each function, but the structure of the code is still the same! void play_hangman() { // TODO: adapt the code below to make it work pick_a_word_to_guess(); while (player_is_alive() &amp;&amp; !player_has_won()) { show_number_of_lives(); show_word_to_guess_with_missing_letters(); const auto guess = get_char_from_user(); if (word_to_guess_contains(guess)) { mark_as_guessed(guess); } else { remove_one_life(); } } if (player_has_won()) { show_congrats_message(); } else { show_defeat_message(); } } Copy Commit "},{"title":"Refactoring​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#refactoring","content":"Now, as we did for the previous game, we will move all this code into its file. Commit "},{"title":"Bonus​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#bonus","content":""},{"title":"Enforcing invariants with a class​","type":1,"pageTitle":"Hangman","url":"assignment/hangman#enforcing-invariants-with-a-class","content":"You noticed that in several functions we had to assert(word_to_guess.size() == letters_guessed.size()). This is because from the point of view of the function their is no guarantee that this invariant has been enforced. But because of that we end up checking the invariant many times, which is a waste of effort and requires more code (and code duplication!). So, how can we improve this situation? Well, classes are made exactly for that reason (and only that reason): enforcing invariants! class WordWithMissingLetters { public: WordWithMissingLetters(std::string_view word) : _word{word} , _letters_revealed(word.size(), false) // The invariant is enforced by the constructor here, and no public function of this class allows users to break the invariant, so we can guarantee that it will be preserved! {} // TODO: implement the methods required by the outside world private: std::string _word; std::vector&lt;bool&gt; _letters_revealed; }; Copy Now think about which of the functions we wrote deserve (or need) to be members of this class? TIP: try to move as few functions as possible inside the class. Only those that need access to the private details of the class must (and should) be moved in the class. Because each member function has to make sure that the invariant is preserved, whereas free functions using this class can rely on the fact that the invariant is enforced by the class. You will also probably need to add some getters. Commit   tip Designing a good class requires time and thinking, but it can simplify the rest of your code later down the road, and makes your code easier to reason about. Small classes that do their job well and enforce one or two invariants are all the rage! (Read Design Great Classes) Bonus Can you find a better name for this class? The current name is great because it is descriptive, but it is a bit long. Can you find a shorter name that is still as clear as the current one? "},{"title":"Advanced Git features","type":0,"sectionRef":"#","url":"lessons/advanced-git-features","content":"","keywords":""},{"title":"Amend​","type":1,"pageTitle":"Advanced Git features","url":"lessons/advanced-git-features#amend","content":"Write a commit but don't push it, you can modify it later. It can be good to save your progress even if it doesn't compile yet and you don't want to push it. "},{"title":"Rebase​","type":1,"pageTitle":"Advanced Git features","url":"lessons/advanced-git-features#rebase","content":"Like amend, but more powerful caution Don't amend or rebase if someone has already pulled your inital commit and starting working on top of it! It will mess up the Git history and merging will be impossible. "},{"title":"Stash​","type":1,"pageTitle":"Advanced Git features","url":"lessons/advanced-git-features#stash","content":""},{"title":"auto","type":0,"sectionRef":"#","url":"lessons/auto","content":"auto Most of the time the type of a variable is obvious and a type declaration would be redundant. In such cases you can use auto instead : std::unique_ptr&lt;MyClass&gt; my_ptr = std::make_unique&lt;MyClass&gt;(); // Bad : we are saying twice that we want a unique pointer to MyClass auto my_ptr = std::make_unique&lt;MyClass&gt;(); // Good : we don't repeat ourselves Copy auto might feel weird at first, but over time you will probably find yourself using it in more and more places, and that's a good thing (IMHO). You can find a very good discussion about auto by Herb Sutter : https://youtu.be/xnqTKD8uD64?t=1703","keywords":""},{"title":"assert","type":0,"sectionRef":"#","url":"lessons/assert","content":"","keywords":""},{"title":"assert​","type":1,"pageTitle":"assert","url":"lessons/assert#assert","content":""},{"title":"static_assert​","type":1,"pageTitle":"assert","url":"lessons/assert#static_assert","content":""},{"title":"Avoid dead code","type":0,"sectionRef":"#","url":"lessons/avoid-dead-code","content":"Avoid dead code Don't leave commented out blocks in your code. If for some reason you want to do so, then leave a comment at the top explaining your reason ; otherwise it is very hard for readers to know what the purpose of that code is and what to do with it : is it still relevant ? is it another option ? or is it just junk ? Example from real code from a company whose name I shall not mention: void Start() { // Utils.SetEnglishLanguage(); // SetupSavedReportsFolder(); // var commandLine = GetCommandLine(); // _commandLineArguments = new CommandLineArguments(commandLine); // // set a specific GUID for the first report // if (_commandLineArguments.ContainsKey(&quot;ReportGuid&quot;)) // BloombergUnityClient.Instance.ReportGuid = Guid.Parse(_commandLineArguments[&quot;ReportGuid&quot;]); // // set a specific address to send the report to. // if (_commandLineArguments.ContainsKey(&quot;ServerAddress&quot;)) // BloombergUnityClient.Instance.config.bloombergServerHost = _commandLineArguments[&quot;ServerAddress&quot;]; // // set a specific TCP port to send the report to. // if (_commandLineArguments.ContainsKey(&quot;ServerPort&quot;)) // BloombergUnityClient.Instance.config.bloombergServerPort = Convert.ToUInt16(_commandLineArguments[&quot;ServerPort&quot;]); // // set the Transmission mode to be use to send the report // if (_commandLineArguments.ContainsKey(&quot;TransmissionMode&quot;)) // BloombergUnityClient.Instance.config.transmissionMode = (BloombergTransmissionMode) Enum.Parse(typeof(BloombergTransmissionMode), _commandLineArguments[&quot;TransmissionMode&quot;]); // // URL to use to get temporary access to write objects (breport) // if (_commandLineArguments.ContainsKey(&quot;S3_MainAPIUrl&quot;)) // BloombergUnityClient.Instance.S3_MainAPIUrl = _commandLineArguments[&quot;S3_MainAPIUrl&quot;]; // // MyServices specific to initialize the session // if (_commandLineArguments.ContainsKey(&quot;US_ApplicationId&quot;)) // { // try // { // _myServices = new MyServices(); // _myServices?.Initialize(_commandLineArguments[&quot;US_ApplicationId&quot;], _commandLineArguments[&quot;US_Email&quot;], _commandLineArguments[&quot;US_Password&quot;]); // } // catch (Exception e) // { // Debug.LogWarning($&quot;MyServices creation failed /r/n {e}&quot;); // } // } BloombergBootstrap.Bootstrap(); Reporter.Initialize(); SetCommandLine(); SetSettings(); Application.logMessageReceivedThreaded += OnLog; } Copy","keywords":""},{"title":"Cache and Branches","type":0,"sectionRef":"#","url":"lessons/cache-and-branches","content":"Cache and Branches https://youtu.be/EmzdmqUWq3o","keywords":""},{"title":"Avoid nested namespaces","type":0,"sectionRef":"#","url":"lessons/avoid-nested-namespaces","content":"Avoid nested namespaces https://youtu.be/xu7q8dGvuwk?t=1198","keywords":""},{"title":"Code reviews","type":0,"sectionRef":"#","url":"lessons/code-reviews","content":"Code reviews https://youtu.be/ta3S8CRN2TM?t=878","keywords":""},{"title":"Composition over Inheritance","type":0,"sectionRef":"#","url":"lessons/composition-over-inheritance","content":"Composition over Inheritance https://youtu.be/Rs9ykyFlebU?t=2177","keywords":""},{"title":"Consistency in style","type":0,"sectionRef":"#","url":"lessons/consistency-in-style","content":"Consistency in style Be consistent with the conventions you choose (e.g. camelCase vs snake_case, prefix of member variables etc.) But also, you shouldn't be too religious about it and try different conventions. A new project is a great opportunity to give another convention a shot. Don't judge conventions solely on your expectations, because we are so used to the one we use that all the others feel weird at first sight. But by trying a convention for a few weeks, your view of it will change. This happened to me with snake_case ; I used to thing it was weird and ugly, but now I thing this is most readable conventions of all because the words are clearly separated and it helps a lot, especially with long names.","keywords":""},{"title":"CMake","type":0,"sectionRef":"#","url":"lessons/cmake","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"CMake","url":"lessons/cmake#brief","content":"To understand modern CMake you need to understand targets. Basically a target is an executable or a library. You will define a target for your executable and describe its source files, and then you will import the targets for each library you use, and will add those targets as a dependency of your executable. Here is an example taken from p6-examples: cmake_minimum_required(VERSION 3.8) project(p6-hello-world) add_executable(${PROJECT_NAME} # Creates a target called ${PROJECT_NAME}, a.k.a. p6-hello-world src/main.cpp # And adds its source files: main.cpp and something.cpp src/something.cpp # Note that you don't need to list the header files here (.h / .hpp) ) add_subdirectory(p6) # Includes the p6 library ; this assumes that you have a folder called p6 at the same level as this CMakeLists.txt file, and that the p6 folder contains a CMakeLists.txt file target_link_libraries(${PROJECT_NAME} PRIVATE p6::p6) # Adds the target &quot;p6::p6&quot; as a dependency of our target ${PROJECT_NAME}. Unfortunately the command is called target_link_libraries() even though it can be used for other things than just linking ; don't get confused! A better name would have been add_dependency() # The name of the target &quot;p6::p6&quot; is up to the library authors. Check out their documentation to know how they called it! # The &quot;::&quot; in the name of the library's target is not mandatory, but library authors often add it because target_link_libraries() can do many different things, and if you make a typo in the name of the target it will ignore it instead of reporting an error. It is only if you have a &quot;::&quot; in the name that target_link_libraries() will know that it can't be anything but a target and will raise an error if the name doesn't actually correspond to a target. Copy And that is all you need for a basic CMakeLists.txt! If all your libraries define a target properly then you don't need anything more to build your project. (If they don't, unfortunately you will have to do their job for them). "},{"title":"CMake tips​","type":1,"pageTitle":"CMake","url":"lessons/cmake#cmake-tips","content":"Now we will see a few useful things that you can do with CMake: "},{"title":"Enabling warnings​","type":1,"pageTitle":"CMake","url":"lessons/cmake#enabling-warnings","content":"if (MSVC) # Visual Studio for Windows target_compile_options(${PROJECT_NAME} PRIVATE /WX /W3) else() # gcc and clang target_compile_options(${PROJECT_NAME} PRIVATE -Werror -Wall -Wextra -Wpedantic -pedantic-errors) endif() Copy /WX and -Werror make your compiler treat warnings as errors, and the other flags enable a lot of useful warnings. tip Warnings are your friends. They exist to protect you from bad practices and bugs. Listen to them! A C++ code that compiles is far from guaranteed to have no bugs! (mostly because of backward compatibility with C). This is why warnings are important! "},{"title":"Setting your C++ version​","type":1,"pageTitle":"CMake","url":"lessons/cmake#setting-your-c-version","content":"You can ask for a specific version of C++: target_compile_features(${PROJECT_NAME} PRIVATE cxx_std_20) Copy (If you don't you will probably get C++11 by default). You can even ask for finer details with parameters like cxx_variadic_templates. This can be useful to increase the portability of your code a little bit (for example if you need C++11 plus only one little feature from C++14). Don't abuse it though because it can be very tedious to maintain! "},{"title":"Adding #define (compile definitions)​","type":1,"pageTitle":"CMake","url":"lessons/cmake#adding-define-compile-definitions","content":"You can #define SOMETHING from CMake. This can be useful to propagate information from CMake into your project. For example you can do cmake target_compile_definitions(${PROJECT_NAME} PRIVATE USE_THIS_FEATURE ) Copy C++ #if USE_THIS_FEATURE // Do something #else // Do something else #endif Copy A very good use case is target_compile_definitions(${PROJECT_NAME} PRIVATE $&lt;$&lt;CONFIG:Debug&gt;:DEBUG&gt; ) Copy which defines DEBUG if you are building in debug mode. (This uses a generator expression. It can be read as: &quot;If the CMake CONFIG is Debug, then return DEBUG, otherwise return nothing&quot;). You can then have debug checks in your code that are only compiled in debug mode and totally removed in release: void assert_shader_is_bound(GLint id) { #if DEBUG GLint current_id; glGetIntegerv(GL_CURRENT_PROGRAM, &amp;current_id); assert(current_id == id &amp;&amp; &quot;The shader is not bound&quot;); #endif } Copy You can also give a value to your #define (by default it gets the value 1): cmake target_compile_definitions(${PROJECT_NAME} PRIVATE WINDOW_NAME=\\&quot;Django ${CMAKE_PROJECT_VERSION}\\&quot; ) Copy C++ glfwCreateWindow(1280, 720, WINDOW_NAME, nullptr, nullptr); // Which expands to: glfwCreateWindow(1280, 720, &quot;Django 1.0&quot;, nullptr, nullptr); Copy "},{"title":"Setting the output path​","type":1,"pageTitle":"CMake","url":"lessons/cmake#setting-the-output-path","content":"By default your executable will end up in build with many other stuff generated by CMake. You can change that with the target property RUNTIME_OUTPUT_DIRECTORY. I personnaly like to do set_target_properties(${PROJECT_NAME} PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin/${CMAKE_BUILD_TYPE}) Copy which gives me ├── bin/ │ ├── Debug │ │ ├── myproject.exe // Built in debug mode │ │ └── ... │ └── Release │ ├── myproject.exe // Built in release mode │ └── ... ├── build/ │ ├── random cmake stuff you don't need to care about │ └── ... ├── src/ │ ├── ... │ └── ... └── CMakeLists.txt Copy "},{"title":"Copying files and folders​","type":1,"pageTitle":"CMake","url":"lessons/cmake#copying-files-and-folders","content":"Very often in projects you need to have files available alongside your executable ; it can be images, 3D models, shaders: anything that is not built into your binary but instead loaded at runtime. You will have those files somewhere in your sources, but when you produce an executable and send it to your friends you must not forget to send the other resource files as well! CMake can help you by automating the process of copying these files to the output folder where your executable is created.  All the files required by CoolLab.exe Here is an example of how you can ask CMake to copy your asset files and folders whenever they change (taken from Cool): #! Copies FILE to the directory where the executable of your TARGET will be created # FILE can be either an absolute or a relative path. If it is relative it will be relative to ${CMAKE_SOURCE_DIR}. # Unlike the default CMake functions this one will re-copy the file whenever it changes function(copy_file TARGET FILE) # Get the part of the file path relative to the top-level CMakeLists.txt cmake_path(RELATIVE_PATH FILE BASE_DIRECTORY ${CMAKE_SOURCE_DIR} OUTPUT_VARIABLE FILE_RELATIVE_PATH) if (NOT FILE_RELATIVE_PATH) set(FILE_RELATIVE_PATH ${FILE}) endif() # Add the copy command set(DUMMY_OUTPUT_NAME ${CMAKE_CURRENT_BINARY_DIR}/DUMMY_${FILE_RELATIVE_PATH}_${TARGET}) add_custom_command( COMMENT &quot;Copying \\&quot;${FILE_RELATIVE_PATH}\\&quot;&quot; OUTPUT ${DUMMY_OUTPUT_NAME} COMMAND ${CMAKE_COMMAND} -E make_directory ${DUMMY_OUTPUT_NAME} # Create a dummy directory that CMake will use as a timestamp reference to know if the actual file has changed, when it checks for the OUTPUT (unfortunately OUTPUT can't use a generator expression so we can't use our actual output file as the OUTPUT) COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_SOURCE_DIR}/${FILE_RELATIVE_PATH} ${OUT_DIR}/${FILE_RELATIVE_PATH} # Actual copy of the file to the destination MAIN_DEPENDENCY ${FILE} ) target_sources(${TARGET} PRIVATE ${FILE}) # Required for the custom command to be run when we build our target endfunction() #! Copies FOLDER and all its files to the directory where the executable of your TARGET will be created # FOLDER can be either an absolute or a relative path. If it is relative it will be relative to ${CMAKE_SOURCE_DIR}. # Unlike the default CMake functions this one will re-copy the files of the folder whenever they change or a file is added function(copy_folder TARGET FOLDER) file(GLOB_RECURSE FILES CONFIGURE_DEPENDS ${FOLDER}/*) foreach(FILE ${FILES}) copy_file(${TARGET} ${FILE} ${OUT_DIR}) endforeach() endfunction() Copy You can either copy these functions into your project, or use this small library (Which is the recommended way because you are guaranteed that it will be up-to-date). "},{"title":"GLOB​","type":1,"pageTitle":"CMake","url":"lessons/cmake#glob","content":"If you don't want to have to list all your .cpp files manually in your CMakeLists.txt you can use file(GLOB_RECURSE MY_SOURCES CONFIGURE_DEPENDS src/*) Copy It will grab the list of all .cpp files in src ant put then in MY_SOURCES. GLOB_RECURSE means that it will also find files that are in the subdirectories of src. If you only want to find the files at the first level of src you can use GLOB instead. CONFIGURE_DEPENDS means that CMake will check before every build to see if files were added or deleted, and if so it will update accordingly. Without it you would need to manually tell CMake to reconfigure each time you add or remove a file. You can then use that list of files like so: add_executable(${PROJECT_NAME} ${MY_SOURCES}) Copy warning Every CMake expert will tell you that you should never use file(GLOB) or file(GLOB_RECURSE). The reason is always the same and can be found in the official CMake documentation: We do not recommend using GLOB to collect a list of source files from your source tree. If no CMakeLists.txt file changes when a source is added or removed then the generated build system cannot know when to ask CMake to regenerate. The CONFIGURE_DEPENDS flag may not work reliably on all generators, or if a new generator is added in the future that cannot support it, projects using it will be stuck. Even if CONFIGURE_DEPENDS works reliably, there is still a cost to perform the check on every rebuild. I disagree with it though, since to me maintaining a list of my .cpp files in my CMakeLists.txt is more of a hassle than having to refresh CMake manually when I add or remove a file. (And CONFIGURE_DEPENDS makes it even less of a hassle). Now that you have the arguments from both sides, pick your poison. "},{"title":"Precompiled header​","type":1,"pageTitle":"CMake","url":"lessons/cmake#precompiled-header","content":"A precompiled header is pretty useful (see Precompiled Header). You can create one with CMake using target_precompile_headers. target_precompile_headers(Cool PUBLIC &lt;vector&gt; &lt;string&gt; &lt;memory&gt; &lt;functional&gt; &lt;imgui/imgui.h&gt; &lt;imgui/misc/cpp/imgui_stdlib.h&gt; &lt;Cool/Log/Log.h&gt; ) Copy "},{"title":"CMake for library authors​","type":1,"pageTitle":"CMake","url":"lessons/cmake#cmake-for-library-authors","content":"As a library, your CMakeLists.txt has one goal: define a target containing all the required information for people to link to your library. Users should only have to do add_subdirectory(libname) target_link_libraries(${PROJECT_NAME} PRIVATE libname) Copy This is possible because a target can store a lot of things: the sources, the include directories, the compile definitions, etc. (this information is known as requirements in the literature). When users call target_link_libraries(${PROJECT_NAME} PRIVATE libname) all this information is propagated to ${PROJECT_NAME} by CMake so that our main target will get the proper includes and so on. If you want to have a look at a real-world example of modern cmake, check out p6 (small library) or Cool (big framework). "},{"title":"add_library()​","type":1,"pageTitle":"CMake","url":"lessons/cmake#add_library","content":"You create your library's target with add_library(libname) Copy (it is the equivalent of add_executable(exename)) "},{"title":"Use the target_xxx() commands​","type":1,"pageTitle":"CMake","url":"lessons/cmake#use-the-target_xxx-commands","content":"To set requirements of your library, always use a target_xxx function. They all have alternatives without the target_ prefix, but those functions affect the global state instead of just your target, which is obviously bad! For example if your project uses libA and libB, you don't want libB to see the include directories and settings of libA! These libraries should be completely independent! They are all used like so: target_xxx(target_name PRIVATE additional_parameters ...) Copy You can also use PUBLIC or INTERFACE instead of PRIVATE (see PRIVATE | PUBLIC | INTERFACE). Here are the most important functions: target_include_directories Specifies the location of the include files. For a library I would suggest to put them in a include/libname folder and to do target_include_directories(libname PUBLIC include) so that the include files are accessed with #include &lt;libname/some_file.hpp&gt;. It can also be nice to add a libname.hpp file that includes all the other header files. It allows users to include the whole library at once with #include &lt;libname/libname.hpp&gt;.target_sources Adds source files to the target (appends to the list that was already set with add_library(libname some_file.cpp)). It can be useful for example if you only need some files in some situations: add_library(Cool src/Cool.cpp) if (USE_OPENGL) target_sources(Cool PRIVATE src/OpenGL/opengl.cpp) elseif (USE_VULKAN) target_sources(Cool PRIVATE src/Vulkan/vulkan.cpp) endif() Copy target_link_libraries To add another target as a dependency.target_compile_options We have seen it in Enabling warnings.target_compile_features We have seen it in Setting your C++ version.target_compile_definitions We have seen it in Adding #define (compile definitions).target_precompile_headers We have seen it in Precompiled header. "},{"title":"PRIVATE | PUBLIC | INTERFACE​","type":1,"pageTitle":"CMake","url":"lessons/cmake#private--public--interface","content":"This is the visibility of the requirements set with target_xxx(). PRIVATE: Only this target will have access to these requirements. When other targets link to this one with target_link_libraries() they will not get the private requirements. For example your warning level should always be private because you do not want to impose it on your dependents: target_compile_options(libname PRIVATE -Werror -Wall) Copy PUBLIC: This target and all of its dependents will be able to access the public requirements. For example if some include directories are used both internaly and by users to access the library, then they should be public: target_include_directories(libname PUBLIC include) Copy Also if you use some other library in your headers, then it will be visible by your users when they include your header, so you need to provide your users with the library: target_link_libraries(Cool PUBLIC glad) Copy INTERFACE: This target will not have access to these requirements but its dependents will. It is a bit peculiar but can be used for example in a header-only library: the library itself does not need to see the include directory (since there is no source files at all to build), but the dependents do: target_include_directories(my-header-only-lib INTERFACE include) Copy This can also be used if the user-facing headers are different from the private ones (e.g. if you have many headers but only want users to see a libname.hpp header that includes all the other ones): target_include_directories(libname INTERFACE include) # The include folder is only used by users and only contains libname.hpp target_include_directories(libname PRIVATE src) # All the headers that we use internally are in src (alongside the .cpp) Copy tip Try to keep things private as much as possible! Don't pollute others for no reason. "},{"title":"Add an alias containing \"::\"​","type":1,"pageTitle":"CMake","url":"lessons/cmake#add-an-alias-containing-","content":"add_library(p6) add_library(p6::p6 ALIAS p6) Copy People care about having a name with :: because target_link_libraries() can do many different things and if you make a typo in the name of the target it will ignore it instead of reporting an error. It is only if you have a :: in the name that target_link_libraries() will know that it can't be anything but a target and will raise an error if the name doesn't actually correspond to a target. As far as the alias name goes, people have different conventions like p6::p6, p6::core etc. Pick one that you like. "},{"title":"Going further​","type":1,"pageTitle":"CMake","url":"lessons/cmake#going-further","content":"Going further Mathieu Ropert, Using Modern CMake Patterns to Enforce a Good Modular Design (1h) Henry Schreiner, Modern CMake (short online book) Stephen Kelly, Embracing Modern CMake (1h) Jason Turner, C++ Weekly - Ep 208 - The Ultimate CMake / C++ Quick Start (30min) "},{"title":"const","type":0,"sectionRef":"#","url":"lessons/const","content":"","keywords":""},{"title":"Bonus trick​","type":1,"pageTitle":"const","url":"lessons/const#bonus-trick","content":"You can use lambdas for const variables that are complex to initialize. "},{"title":"Bad :( (because x is not const)​","type":1,"pageTitle":"const","url":"lessons/const#bad--because-x-is-not-const","content":"enum class MyEnum { value0, value1, value2, }; int do_something(MyEnum my_enum) { int x; switch(my_enum) { case MyEnum::value0 : x = 17; break; case MyEnum::value1 : x = 5; break; case MyEnum::value2 : x = 30; break; default: x = 0; break; } // use x return x + 2; } int main() { return do_something(MyEnum::value1); } Copy "},{"title":"Good :)​","type":1,"pageTitle":"const","url":"lessons/const#good-","content":"enum class MyEnum { value0, value1, value2, }; int do_something(MyEnum my_enum) { const int x = [my_enum]() { switch(my_enum) { case MyEnum::value0 : return 17; case MyEnum::value1 : return 5; case MyEnum::value2 : return 30; default: return 0; } }(); // parenthesis to call the lambda function that was just declared // use x return x + 2; } int main() { return do_something(MyEnum::value1); } Copy "},{"title":"C++ casts","type":0,"sectionRef":"#","url":"lessons/cpp-casts","content":"C++ casts 5 min","keywords":""},{"title":"Dear ImGui","type":0,"sectionRef":"#","url":"lessons/dear-imgui","content":"Dear ImGui","keywords":""},{"title":"Use a debugger","type":0,"sectionRef":"#","url":"lessons/debugger","content":"","keywords":""},{"title":"How to​","type":1,"pageTitle":"Use a debugger","url":"lessons/debugger#how-to","content":""},{"title":"Running your debugger​","type":1,"pageTitle":"Use a debugger","url":"lessons/debugger#running-your-debugger","content":"If you are using VS Code and the CMake extension (ms-vscode.cmake-tools), then you can simply click on the little bug in your toolbar:If you are using something else, go look for the info! All IDEs come with a debugger and an easy way of launching it. "},{"title":"Setting breakpoints​","type":1,"pageTitle":"Use a debugger","url":"lessons/debugger#setting-breakpoints","content":"Even if you don't have a crash in your program, you might want to see what is going on if for example a function doesn't behave as expected. You can set a breakpoint, usually by clicking on the left of the line "},{"title":"Inspecting the state of your program​","type":1,"pageTitle":"Use a debugger","url":"lessons/debugger#inspecting-the-state-of-your-program","content":"Once your program paused on a breakpoint or a crash, you can see the value of all variables (by hovering over them or looking at the variables window):  You can also see all the functions that have been called previously, called the call stack, and jump to them:  Finally, you can keep executing the program step by step and see what happens:  "},{"title":"Debug vs Release","type":0,"sectionRef":"#","url":"lessons/debug-vs-release","content":"Debug vs Release","keywords":""},{"title":"Deleted functions","type":0,"sectionRef":"#","url":"lessons/deleted-functions","content":"Deleted functions You can delete functions to prevent them from beeing used. This is mostly used to prevent a type from being copied ; for example std::unique_ptr can't be copied because there can only be one owner of the data, unlike std::shared_ptr. It can be done with the =delete syntax: class MyClass{ //... MyClass(const MyClass&amp;) = delete; // delete the copy constructor MyClass&amp; operator=(const MyClass&amp;) = delete; // delete the copy assignment //... }; Copy","keywords":""},{"title":"Dependencies","type":0,"sectionRef":"#","url":"lessons/dependencies","content":"","keywords":""},{"title":"The Singleton attempt​","type":1,"pageTitle":"Dependencies","url":"lessons/dependencies#the-singleton-attempt","content":"One tempting solution is to resort to the Singleton (anti-)pattern. In its simplest form it consists in making your class static 1 so that anyone can access it from anywhere. It has the advantage that you don't need to pass an instance around (which would probably require you to modify the signature of quite a few fonctions to pass the instance to the parts that need it). This makes the Singleton a really good solution in the short term. But the Singleton can end up causing a few problems, hence why most people have stopped using it : It prevents you from having multiple instances of the same class. Obviously you are a reasonable person and you use a Singleton only for classes that you need one single instance of. . . But you might realize later that actually you need to have multiple instancies. I have a few examples from my personal experience : an history seems like it is unique across the application, until you realize that having separate histories for separate systems is a useful feature. And the argument to rule them all : what if you want to have multiple instances of your application in parallel ? Then you can't have any static data because it would be shared accross the instancies of your application. For example think of a workspace in a drawing application : you might want to have multiple drawings open at once, each with it's own layer system, history, etc.It reduces testability : each class that depends on a static class cannot be used outside of the application. This is a big problem for testing (and also for reusing your code !). When testing we usually like to create fake instancies of the dependencies of a class to test that class. For example if you depend on a server, it is nice to make your tests with a mock server (for example that returns a dummy answer when you make a request, whithout even making a web call to a service) rather that the production one ! It prevents breaking things or even relying on having a server running. Also you can test different scenarios – like the server beeing down – whithout having to shut down your actual server ! This is also why you should depend on interfaces and never on concrete classes. If you depend on an IServer you can then have different test implementations : MockServerRunning, MockServerDown, MockServerLaggy etc.It hides dependencies. Even though it is a pain to write each dependency explicitly in the signature of functions, later down the road you will be happy to be able to see at a glance what is required for a given function (when refactoring for example). It will also be easier to reuse the code later in other projects if the only dependencies are at the function boundary (aka in the signature). "},{"title":"The best practices​","type":1,"pageTitle":"Dependencies","url":"lessons/dependencies#the-best-practices","content":""},{"title":"Dependency Injection​","type":1,"pageTitle":"Dependencies","url":"lessons/dependencies#dependency-injection","content":"Yes, you should receive as parameters all the classes / systems that you depend on. Storing them as members isn't the cleanest either in my opinion (this can be qualified though) ; I would tend to only store a reference to a class if there is a very strong coupling between the two (like a CameraController and the corresponding Camera) (EDIT : I would almost never store references because it makes copying and assigning pretty troublesome / impossible). You should always send references as parameters to each function that needs them : it prevents you from introducing extra member variables, and makes it clearer which parts of your class actually need or act upon a dependency. If you end up with too many arguments, maybe grouping them in a struct can be a good idea. This should be considered carefully though because it can lead to introducing unnecessary dependencies (if a class X needs 4 out of the 5 classes packaged in a struct Y, it can be tempting to make X depend on Y, although it will grab one unnecessary dependency, which is bad). https://youtu.be/qkGxy4c64Jg About storing a reference to a dependency​ Storing a reference is a problem because it makes your type more complex than it needs to be. I realized that after a 1 hour debugging session filled with cryptic template error messages. Having a reference in your type will make it non-copy-assignable ! That is because when trying to assign to a refence, you are actually assigning to the object behind the reference ! You cannot modify where the reference points to after its creation ! Let's have an example : class MyClass { public: // Constructor MyClass(const MyDependency&amp; my_dependency) : _my_dependency{my_dependency} // OK : initializes the reference to point to my_dependency {} // Copy Constructor MyClass(const MyClass&amp; o) : _my_dependency{o._my_dependency} // OK : initializes the reference to point to o.my_dependency {} // Copy Assignment operator MyClass&amp; operator=(const MyClass&amp; o) { _my_dependency = o._my_dependency; // Bad ! This doesn't change where the reference is pointing to, but instead tries to modify the object that the reference points to ! Here this is a compile error because _my_dependency is a const&amp;, but if it was not const, that would be a silent bug modifying the object pointed to by _my_dependency!!! return *this; } private: const MyDependency&amp; _my_dependency; }; Copy Here is a nice article about problems around references by Herb Sutter : https://herbsutter.com/2020/02/ Also when you store a reference or a pointer, you must make sure that the pointed object outlives the class where the reference is stored ; otherwise you will get a dangling reference or pointer ! For example if your dependency lives in a std::vector, and the vector gets resized at some point, all the references to elements of that vector get invalidated ! If you stored one such reference, you are in trouble ! On the contrary if you pass a reference each frame, you will not notice the change of adress in memory at all. When you have no choice but to store the dependency​ An interesting exception to the do not store your dependencies rule is if you need your dependency in the destructor of your class (or in an operator like +=) : in those cases, you cannot pass any arguments ! Therefore you have no other choice but to store the dependency inside the class (or have it global but that would be even worse !) In such cases2, you can use a std::reference_wrapper: it will act like a reference, but still be copyable. "},{"title":"Dependency Inversion (the D of SOLID)​","type":1,"pageTitle":"Dependencies","url":"lessons/dependencies#dependency-inversion-the-d-of-solid","content":"The interfaces should be owned by the high level that uses it, not by the low level that implements it. "},{"title":"Concepts vs Interfaces​","type":1,"pageTitle":"Dependencies","url":"lessons/dependencies#concepts-vs-interfaces","content":"Concepts are better than interfaces because they can also require the existance of free functions, not only methods. For example if you want to require that each shape is drawable, with an interface it would require that draw() be a method of each Shape class. With concepts you can require that a free function draw(Shape const auto&amp; shape) exists for each type following the Shape concept. And free functions are great for many reasons ! (Single Responsibility Principle, Open-Close Principle, etc. See Free your functions) "},{"title":"To go further​","type":1,"pageTitle":"Dependencies","url":"lessons/dependencies#to-go-further","content":"About the Singleton and alternatives to it About SOLID by Klaus Iglberger Or rather have a static instance available through a MyClass::get() method, because it gives you control over the instanciation and destruction order, which is important when you have dependencies between your singletons, and when you use multithreading.↩I met such a case when creating wrapper classes for Vulkan resources: they need a reference to the device to be destructed, so I had to store a handle to the device in each wrapper class.↩ "},{"title":"Design Great Classes","type":0,"sectionRef":"#","url":"lessons/design-great-classes","content":"","keywords":""},{"title":"Keep it small​","type":1,"pageTitle":"Design Great Classes","url":"lessons/design-great-classes#keep-it-small","content":"Try not to mix concerns inside a single class: it should have only one reason to change. A good indicator: if none of your methods needs to have access to all members at once, you can probably split that class in two or more smaller classes. "},{"title":"No private methods​","type":1,"pageTitle":"Design Great Classes","url":"lessons/design-great-classes#no-private-methods","content":"Private methods are bad because they can't be tested and they can't be reused outside of the class! Think about it: what is their advantage over a free function? Apart from the fact that they have access to all the members of the class, and therefore they don't need to declare parameters (which is a bad reason, don't be lazy!), I can't think of anything3. So my guideline will be: don't use private member functions, use free functions that take as a parameter the things they need. I am talking about the semantic differences here, because in C++ a class and a struct can do exactly the same things. The only difference is that by default if you don't use an access specifier everything is private in a class and public in a struct.↩Even though I am not opposed to having methods in a struct.↩Actually they might be used in inheritance hierarchies. But since inheritance hierarchies are a bad practice too, this doesn't count 😛↩ "},{"title":"Documentation","type":0,"sectionRef":"#","url":"lessons/documentation","content":"","keywords":""},{"title":"Document for users​","type":1,"pageTitle":"Documentation","url":"lessons/documentation#document-for-users","content":""},{"title":"Document for developers​","type":1,"pageTitle":"Documentation","url":"lessons/documentation#document-for-developers","content":"State your intentions, the alternatives you considered, the reason that made you choose this particular implementation etc. Don't be shy, talk a lot, leave a trace for others. Even if you are unsure or not confident about your design, say it ! It will help future developers have no remorse to rewrite your code, and be confident there isn't some important thing that they are missing and that made you write the code this way. "},{"title":"Designated Initializers","type":0,"sectionRef":"#","url":"lessons/designated_initializers","content":"Designated Initializers https://youtu.be/nm45t2fnUms","keywords":""},{"title":"Don't overfocus on performance","type":0,"sectionRef":"#","url":"lessons/dont-overfocus-on-performance","content":"Don't overfocus on performance Because most applications don't really need performance, and correctness is their main concern. Often, the compute-heavy parts are handled by libraries and you don't need to worry about that. If the code that you write doesn't weigh much in the performance scale, don't waste time optimizing it, or worse, don't optimize it at the expense of readability / maintainability ! Sometimes you have to not be obsessed with performance and have a critical eye on wheter this performance matters. Saving 1 nanosecond every second doesn't matter to anyone! (accept maybe in high-frequency trading) Know your environment and your performance requirements, and don't push it further than you need.","keywords":""},{"title":"DRY: Don't repeat yourself","type":0,"sectionRef":"#","url":"lessons/dont-repeat-yourself","content":"DRY: Don't repeat yourself","keywords":""},{"title":"Enums","type":0,"sectionRef":"#","url":"lessons/enums","content":"Enums","keywords":""},{"title":"Error Handling","type":0,"sectionRef":"#","url":"lessons/error-handling","content":"","keywords":""},{"title":"Exceptions​","type":1,"pageTitle":"Error Handling","url":"lessons/error-handling#exceptions","content":"Despite their bad reputations, they are actually pretty good and you should consider using them. Here is a very nice paper by Bjarne Stroustrup defending them : http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf(answering to a discussion opened by https://www.youtube.com/watch?v=GC4cp4U2f2E) "},{"title":"Use a formatting tool","type":0,"sectionRef":"#","url":"lessons/formatting-tool","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Use a formatting tool","url":"lessons/formatting-tool#brief","content":"Tools can format your code automatically: fix indentation, add spaces consistently, put curly braces where you want them, etc.It saves a lot of time because it means you don't have to worry about it and do it manually! Also, it ensures a consistency in style across the whole codebase and all the developpers. "},{"title":"Details​","type":1,"pageTitle":"Use a formatting tool","url":"lessons/formatting-tool#details","content":"For C++, Clang format is the most used one and I would recommend it. You can use it inside VSCode through this extension: xaver.clang-format. Once installed you will need go in your VSCode settings and set Default Formatter to Clang-Formatenable Format on Save You will also need to put a configuration file named .clang-format at the root of your project to specify how the formatting should be done. You can use this great website to configure it. If you don't want to spend too many time tweaking it yourself, you can use mine: https://github.com/CoolLibs/Cool/blob/main/.clang-format. "},{"title":"Prefer free functions","type":0,"sectionRef":"#","url":"lessons/free-functions","content":"Prefer free functions Free functions help a lot with decoupling, code reuse, testing, etc. NB: This doesn't mean that member functions are bad or that you should never use them. If you need to encapsulate data and only access it in well defined ways, a member function is the way to go. But if something can be done using only the public interface of a class, then a free function is preferable to a member function. The problem is that methods depend on the whole class and, if your class is quite large (which it shouldn't be but that's a different topic) then you probably have many unnecessary dependencies. It makes it harder to reason about methods at the call site because they could use any information from the class and, if they are not const, modify any member of the class. On the other hand free functions are very clear about their dependencies: it's just the arguments of the function, nothing is hidden. And even if you pass the whole class to the function, at least it can only use the public interface of the class which greatly limits the harm that it could do. Free functions are also very easy to reuse, since they are not burried inside any class and have minimal dependencies. Going further David Sankel, Building Software Capital: How to write the highest quality code and why (1min) Klaus Iglberger, Free Your Functions! (1h)","keywords":""},{"title":"Functional programming","type":0,"sectionRef":"#","url":"lessons/functional-programming","content":"Functional programming Functional programming is an important paradigm that has gotten a lot of attention recently (it took of long after Object Oriented programming). A lot of very good techniques have emerged from this field and have been incorporated in many languages, including C++. std::optional, std::variant, std::transform and many others are inherited1 from Functional Programming. Going further A sweet intro to some functional concepts Lambda calculus, the theory behind functional programming TODO TODO TODO TODO Notice the pun 😉↩","keywords":""},{"title":"friend","type":0,"sectionRef":"#","url":"lessons/friend","content":"friend There are very few good reasons to use friend. The only one I can think of is when you are forced, for implementation reasons, to split something into two classes but conceptually it really is one united block. For example, when implementing the state pattern : you have a class X that holds a state S. Although S needs to be a seperate class in order to have different implementations and be changed at runtime, it really is part of X and should be allowed to access it's internals like no one else. Even in that case, you should first wonder wether it wouldn't make sense to put in your public interface all the things that S needs. If the answer is now, then maybe you have a use case for friend. What really bothers me with friend is that it is all or nothing. I wish I could specify that only one given method will be usable by a specific class : &quot;this method is not part of the public API, but it can be used by this one class who knows how to handle it&quot;. With the current friend, all friends suddenly have access to all methods and members. (Maybe this problem is lessened when the Single Responsibility Principle is strictly followed and each class really is an all or nothing package (since there is only one thing in the package), but still I don't like the fact the friends can access member variables) =&gt; Useless since C++20 and modules, which allow us a much finer grain control over visibility PassKey idiom","keywords":""},{"title":"Use Git","type":0,"sectionRef":"#","url":"lessons/git","content":"","keywords":""},{"title":"Good practices​","type":1,"pageTitle":"Use Git","url":"lessons/git#good-practices","content":"As soon as you have made meaningful progress and the code compiles, make a commit! Try to avoid putting unrelated changes in the same commit. "},{"title":"Git Pull Requests","type":0,"sectionRef":"#","url":"lessons/git-pull-request","content":"Git Pull Requests (also known as merge requests in GitLab)","keywords":""},{"title":"Git submodules","type":0,"sectionRef":"#","url":"lessons/git-submodules","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Git submodules","url":"lessons/git-submodules#brief","content":"Submodules are used to link to other repositories: instead of copying a library into your project, you can use a submodule to keep a reference to the original repository. This has several advantages: It doesn't take space on your repo: it is merely a link and people can download it if they want toIt is easier to update: you simply have to pull from the original repositoryYou always know which version of the library you are using: it is written in the Git submoduleIf this is a library that you are developing, you can make the modifications in the project that uses the library, and then push to the repo of the library! This is the biggest selling point to me because it means that you can, in one place, work on the library and the project that uses it. It feels like you have one repo even though there are actually two and one of them can be shared across many projects. "},{"title":"Adding a submodule​","type":1,"pageTitle":"Git submodules","url":"lessons/git-submodules#adding-a-submodule","content":"With GitKraken you can simply click the Add submodule button and then specify the url of the repo and the folder where you want to clone the submodule:  With the command line you can do: git submodule add https://github.com/url/to/the/repo folder/where/to/clone Copy "},{"title":"Cloning a project that uses a submodule​","type":1,"pageTitle":"Git submodules","url":"lessons/git-submodules#cloning-a-project-that-uses-a-submodule","content":"It doesn't work really well with GitKraken so I recommend to do that step with the command line: git clone --recursive https://github.com/url/to/the/repo Copy If you forget to use that --recursive flag, the submodules won't be cloned. To fix that you can always do git submodule update --init --recursive Copy "},{"title":"Use an IDE","type":0,"sectionRef":"#","url":"lessons/ide","content":"","keywords":""},{"title":"Go to definition​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide#go-to-definition","content":""},{"title":"Find all occurences​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide#find-all-occurences","content":""},{"title":"Search for a word in the current file​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide#search-for-a-word-in-the-current-file","content":""},{"title":"Search for a word in the whole project​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide#search-for-a-word-in-the-whole-project","content":""},{"title":"Launching the project​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide#launching-the-project","content":""},{"title":"Rename​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide#rename","content":""},{"title":"Putting multiple cursors at once​","type":1,"pageTitle":"Use an IDE","url":"lessons/ide#putting-multiple-cursors-at-once","content":""},{"title":"Immediately Invoked Function","type":0,"sectionRef":"#","url":"lessons/immediately-invoked-function","content":"Immediately Invoked Function","keywords":""},{"title":"#if defined()","type":0,"sectionRef":"#","url":"lessons/if-defined","content":"#if defined() #if defined(SOMETHING) offers more flexibility than #ifdef SOMETHING. For example you can use negation, and and or : #if defined(SOMETHING) &amp;&amp; !defined(SOMETHING_ELSE) You can also it with #elif : #if defined(MACRO1) // ... #elif defined(MACRO2) // ... #elif defined(MACRO3) // ... #else // ... #endif Copy","keywords":""},{"title":"Lambda functions","type":0,"sectionRef":"#","url":"lessons/lambda","content":"Lambda functions","keywords":""},{"title":"Linked lists","type":0,"sectionRef":"#","url":"lessons/linked-list","content":"Linked lists Linked lists are rarely usefull. All the theoretical advantages in insertion time and what not are actually murdered by the awfull cache coherency that make them actually very slow. The only real I know them is that they never invalidate refercences.","keywords":""},{"title":"Make it work, then make it good","type":0,"sectionRef":"#","url":"lessons/make-it-work-then-make-it-good","content":"Make it work, then make it good Refactoring!","keywords":""},{"title":"Markdown","type":0,"sectionRef":"#","url":"lessons/markdown","content":"","keywords":""},{"title":"Subtitle​","type":1,"pageTitle":"Markdown","url":"lessons/markdown#subtitle","content":""},{"title":"Sub-subtitle​","type":1,"pageTitle":"Markdown","url":"lessons/markdown#sub-subtitle","content":"italic text bold text a link Abulletpointlist tip As you can see the Markdown syntax is very light and doesn't hurt the source text's libility (unlike html). You can learn more about the Markdown syntax here. "},{"title":"Master your IDE","type":0,"sectionRef":"#","url":"lessons/master-your-ide","content":"","keywords":""},{"title":"Use extensions​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#use-extensions","content":"There are many extensions that can help you! Check out the recommended extensions for your language or discover what other people use. Here are some great extensions for VS Code that I recommend: ms-vscode.cpptools-extension-pack: The Basic C++ extensionscoenraads.bracket-pair-colorizer-2: This colors matching pairs of brackets ; it makes your code more readablems-vsliveshare.vsliveshare: Allows you to code remotely on someone else's computer. Is it amazing to work together! "},{"title":"Learn the shortcuts​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#learn-the-shortcuts","content":"My tip is to try, once in a while, to pick an action that you often need (like deleting a whole line, selecting all the occurences of a word in the text, opening the Settings menu, etc.) and go search for the shortcut (either on the Internet or in the great VS Code shortcut menu (in File-&gt;Preferences-&gt;Keyboard Shortcuts)). And if you don't like the default shortcut, you can always change it! tip Take the time to learn! Next time you say &quot;Oh I wish I knew how to do xxx faster!&quot; take the time to learn how to do it! It will save you a lot of time later down the road! You can also discover shortcuts by watching other people write code. Take the time to ask them what the shortcut is, or go search for it! "},{"title":"Adapt the Settings​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#adapt-the-settings","content":"Take the time to open the Settings menu of your IDE, and read through it! You will discover a lot of the hidden functionalities of your IDE, and you might be able to change its behaviour to better suit your needs! I often feel silly when I discover that the functionality I was dreaming of was actually available, waiting for me to enable it. Same for the extensions you use: they can be configured in a lot of different ways, so check out their settings! (For example, did you know that you can tell the CMake extension where your CMakeLists.txt is? It doesn't have to be at the root of the project!) "},{"title":"A few great actions​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#a-few-great-actions","content":"Do you know how to do each of these? If not, try to learn them one by one: "},{"title":"Select multiple occurences of the same word​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#select-multiple-occurences-of-the-same-word","content":""},{"title":"Delete the current line​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#delete-the-current-line","content":""},{"title":"Move the current line up​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#move-the-current-line-up","content":""},{"title":"Duplicate the current line​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#duplicate-the-current-line","content":""},{"title":"Go to a file​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#go-to-a-file","content":"CTRL + P "},{"title":"Switch between a header file and the corresponding .cpp file​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#switch-between-a-header-file-and-the-corresponding-cpp-file","content":""},{"title":"Close all open tabs​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#close-all-open-tabs","content":""},{"title":"Save all open tabs​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#save-all-open-tabs","content":""},{"title":"Launch the project​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#launch-the-project","content":""},{"title":"Build the project​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#build-the-project","content":""},{"title":"Debug the project​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#debug-the-project","content":""},{"title":"Go to definition​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#go-to-definition","content":""},{"title":"Find all occurences​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#find-all-occurences","content":""},{"title":"Search for a word in the current file​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#search-for-a-word-in-the-current-file","content":""},{"title":"Search for a word in the whole project​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#search-for-a-word-in-the-whole-project","content":""},{"title":"Rename​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#rename","content":""},{"title":"Putting multiple cursors at once​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide#putting-multiple-cursors-at-once","content":""},{"title":"Measuring performance","type":0,"sectionRef":"#","url":"lessons/measuring-performance","content":"Measuring performance","keywords":""},{"title":"Multithreading","type":0,"sectionRef":"#","url":"lessons/multithreading","content":"Multithreading jthread in C++20","keywords":""},{"title":"Move semantics","type":0,"sectionRef":"#","url":"lessons/move-semantics","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Move semantics","url":"lessons/move-semantics#brief","content":"You all know what copying an object means. But did you know that we can do better in some circumstances? move is an optimization of copy. For example consider: std::vector&lt;int&gt; create_n_integers(int n) { std::vector v; for (int i = 0; i &lt; n; ++i) { v.push_back(n); } return v; } std::vector&lt;int&gt; my_vector = create_n_integers(10000000); Copy It might look like we are doing a copy: a vector is created inside create_n_integers and then when we do my_vector = create_n_integers(10000000) we copy the vector from create_n_integers into my_vector. And you know that a vector can be big and therefore its copy can be expensive! All of that is true, but the above code is still perfectly fine. This is because the compiler knows that there is no need to do a copy and that it can do a move instead: same effect, but faster. So, what is a move? The idea is that when an object is about to be destroyed, there is no need to keep that object intact ; our &quot;copy&quot; operation is therefore allowed to modify it. That &quot;destructive copy&quot; is called a move. Why would modifying the &quot;copied&quot; object be useful? Let's take the example of a std::vector&lt;int&gt; v1. A vector is implemented as a pointer to an array of elements on the heap. If we ask for a copy of the vector (std::vector&lt;int&gt; v2 = v1;) then it has to copy all the elements of the array into a new array, because we want v1 and v2 to be independent objects. If we were to only copy the pointer, then v1 and v2 would point to the same array and modifying v1 would also affect v2, which would be very confusing and impractical. Therefore making a copy of a big vector is slow because each of the (possibly many) elements of the vector has to be copied. But if we know that v1 is no longer used, then we don't care if it points to the same array as v2! There is no way of touching v1 and accidentaly modifying v2! In that case we can simply copy the pointer and save a lot of time. tip This is the power of move: the compiler optimizes your copy when it knows that you won't see the difference between a copy and a move. So, do you need to think about move all the time? Luckily, no! It will happen automatically in places where it can. Just remember that having a function that returns a vector by value is not a bad thing because the copy will be optimized into a move, which is cheap. Another explanation The Cherno, Move Semantics in C++ (13min) "},{"title":"Implementing move for your own classes​","type":1,"pageTitle":"Move semantics","url":"lessons/move-semantics#implementing-move-for-your-own-classes","content":"For most of your classes a move constructor will be defined automatically (just like the copy constructor) and you have nothing to do. The only time where you need to implement move yourself is if your class has an explicitly defined destructor or copy constructor (see The Rule of 5). This should be rare because if all the members of your class already have move and destruction defined, then your class will get a default move and destructor that will do the right thing and everything will be fine. The only case where you would need to define destruction and move is when you manage a resource like a pointer, an object from a C api that needs to be freed, etc. Note that in the case of a pointer the problem is already solved by std::unique_ptr and std::shared_ptr. Please don't allocate your pointers with raw new and don't add destructors to your classes just to manage the pointers that you allocated. Use std::unique_ptr instead and you won't even need to think about destructors and move constructors. If you ever need to create a wrapper similar to a std::unique_ptr for some resource (like an OpenGL id), here is how to do it: class UniqueBuffer { public: UniqueBuffer() { glGenBuffers(1, &amp;_id); // Do whatever you need to create the resource } ~UniqueBuffer() { glDeleteBuffers(1, &amp;_id); // Do whatever you need to delete the resource } UniqueBuffer(const UniqueBuffer&amp;) = delete; // We disable copying UniqueBuffer&amp; operator=(const UniqueBuffer&amp;) = delete; // We disable copying UniqueBuffer(UniqueBuffer&amp;&amp; rhs) noexcept // Move constructor : _id{rhs._id} { rhs._id = 0; // Make sure that rhs won't delete the _id we just copied } UniqueBuffer&amp; operator=(UniqueBuffer&amp;&amp; rhs) noexcept // Move assignment operator { if (this != &amp;rhs) { // Make sure that we don't do silly things if we try to move an object to itself glDeleteBuffers(1, &amp;_id); // Delete the previous object _id = rhs._id; // Get the new object rhs._id = 0; // Make sure that rhs won't delete the _id we just copied } return *this; // move assignment must return a reference to this, so we do it } GLuint operator*() const { return _id; } // The getter for the wrapped `_id`. You can also have it as a function called id() but I like to use the dereference operator for that purpose (*my_wrapper). private: GLuint _id; }; Copy Many things to note: We disable copying because we can't simply copy the _id (the copy would refer to the same object as the original, which would be problematic just like in our vector example), and we can't create a new object with glGenBuffers because we have no idea what was stored in that buffer by users (if we were to do a naive copy constructor, then when users ask for a copy they would get a new empty buffer instead of a copy of all the vertex data or whatever that was added to the buffer). Disabling copy also prevents accidental copies of objects that are not supposed to be copied (e.g. because they are big and the copy would be expensive).We do rhs._id = 0; when we move. This is because if we don't, then when rhs gets destroyed it will destroy its _id, which is the same that our new object is using, which would make it invalid!We do if (this != &amp;rhs). This is because someone could call v = std::move(v); (in generic code it can happen and it is not that obvious and sometimes you need to do it). In such cases without the check we would do rhs._id = 0; but since rhs is ourself we would just loose our _id!The signature for move operations contains UniqueBuffer&amp;&amp;. This &amp;&amp; symbol is called an r-value reference ; it is kind of like the usual reference &amp; (called an l-value reference) but it indicates that you are allowed to modify the object and steal its resources. Basically it means that it is okay to move from the object. The move constructor and move assignment are marked noexcept which is extremely important. If you don't then STL containers like vector will not use your move and will do a copy instead (because it would be problematic if an exception was thrown while a vector is resizing and moving objects to the new location). This noexcept costs you nothing and allows great performance improvements when you store your objects in a vector, so please don't forget it! tip Make your wrappers as small as possible. Because if you need to define a move constructor in a big class then you need to tell it to move each member variable, which is tedious and error prone. Plus you will probably need that resource in several classes and you don't want to have to repeat the destruction code in each of them. You can find examples of such wrappers in GL++. "},{"title":"Asking for a move with std::move​","type":1,"pageTitle":"Move semantics","url":"lessons/move-semantics#asking-for-a-move-with-stdmove","content":"Move happens automatically: When returning from a functionWhen passing a temporary value to a function (a.k.a. something that was not put in a variable). In f(MyClass{1, 3});, MyClass{1, 3} is not given any name: it is a temporary and will be moved into f instead of copied. But if you have std::vector&lt;MyClass&gt; v; MyClass my_class{1, 3}; // Maybe do something with my_class // . . . v.push_back(my_class); Copy when passing my_class to push_back it will be copied and not moved. But let's say that we don't need my_class after the call to push_back: then it would be nice to move my_class into push_back and avoid a copy. We can ask for that by doing v.push_back(std::move(my_class));. This works because push_back is overloaded to accept both normal references (const MyClass&amp;) and r-value references (MyClass&amp;&amp;). caution After calling std::move() on an object, don't use it again! It has been moved away and might not be valid anymore. To learn more on that, check out Beware: Zombies. "},{"title":"Return value optimization (RVO)​","type":1,"pageTitle":"Move semantics","url":"lessons/move-semantics#return-value-optimization-rvo","content":"Sometimes the compiler can do even better than move. When you are returning an unnamed variable from a function you are guaranteed that there won't even be a move, the variable will be created in place at the call site. This is called RVO and is guaranteed by the standard. std::vector&lt;int&gt; create_some_vector(int x) { int a = x + 1; int b = x * 2; return std::vector&lt;int&gt;{{a, b}}; // RVO applies because we did not give a name to the variable std::vector&lt;int&gt;{{a, b}}, we returned it directly } std::vector&lt;int&gt; v = create_some_vector(2); // No copy nor move. It is the same as doing std::vector&lt;int&gt; v = {2 + 1, 2 * 2}; Copy Compilers can do other optimizations, but RVO is (currently) the only one that is guaranteed. In our first example RVO doesn't apply because we gave a name to the variable that we return (v). But chances are your compiler will still optimize the move away ; this is known as NRVO (Named Return Value Optimization). "},{"title":"Going further​","type":1,"pageTitle":"Move semantics","url":"lessons/move-semantics#going-further","content":"Going further Abseil's tip (5min) TODO put a link to Klaus' conference when the CppCon 2021 is available on Youtube. Arthur O'Dwyer, Return Value Optimization: Harder Than It Looks, Details about RVO (25min) "},{"title":"Naming","type":0,"sectionRef":"#","url":"lessons/naming","content":"Naming Finding the right name sometimes gives you ideas of how to improve your design. For example I wanted a struct to hold a width and a height to represent the size of some images. I started calling it RectangleSize to be more generic, but when I realized it was more of an ImageSize, it helped me a lot ! Because then I added an invariant to that struct : width &gt;= 1 and height &gt;= 1. This is very usefull because most graphics API won't accept an empty image anyways and I was doing tests all over the place to make sure width &gt;= 1 and height &gt;= 1. But now that I have this invariant for ImageSize I can use it safely without checks, since they already took place in the constructor of ImageSize. If we want to allow for an empty image size, we can use std::optional&lt;ImageSize&gt; instead, but then we will always have to check to see if it is nullopt. Going further Kevlin Henney on naming (10min) Kate Gregory on naming (1h)","keywords":""},{"title":"std::optional","type":0,"sectionRef":"#","url":"lessons/optional","content":"std::optional https://youtu.be/ojZbFIQSdl8?t=1056","keywords":""},{"title":"Orthogonality","type":0,"sectionRef":"#","url":"lessons/orthogonality","content":"Orthogonality TODO: do I keep it ; or put a general chapter on coupling","keywords":""},{"title":"Pointers vs References","type":0,"sectionRef":"#","url":"lessons/pointers-vs-references","content":"Pointers vs References Pointers can be null Pointers can be repointed https://youtu.be/YnWhqhNdYyk?t=2253","keywords":""},{"title":"Polymorphism","type":0,"sectionRef":"#","url":"lessons/polymorphism","content":"","keywords":""},{"title":"Static Polymorphism​","type":1,"pageTitle":"Polymorphism","url":"lessons/polymorphism#static-polymorphism","content":"Function overloading and templates. https://www.fluentcpp.com/2017/04/28/extract-interface-cpp/ "},{"title":"Dynamic Polymorphism​","type":1,"pageTitle":"Polymorphism","url":"lessons/polymorphism#dynamic-polymorphism","content":"Base class vs std::variant. When people say why OOP is so great, the biggest (hidden) argument is most often that polymorphism is great. But beware the confusion ! OOP is not the only way of achieving polymorphism ; generic programming with std::variant is an option too. "},{"title":"To Go Further​","type":1,"pageTitle":"Polymorphism","url":"lessons/polymorphism#to-go-further","content":"Check this out (Comparison of different approaches to achieve polymorphism) "},{"title":"Precompiled Header","type":0,"sectionRef":"#","url":"lessons/precompiled-header","content":"Precompiled Header https://youtu.be/eSI4wctZUto","keywords":""},{"title":"<random>","type":0,"sectionRef":"#","url":"lessons/random","content":"&lt;random&gt; going further Stephan T. Lavavej, rand() Considered Harmful (30min)","keywords":""},{"title":"The Rule of 5","type":0,"sectionRef":"#","url":"lessons/rule-of-5","content":"The Rule of 5 The Rule of 5 states that if you write a special member function (a.k.a. a destructor, a copy constructor, a copy assignment, a move constructor or a move assignment), then you need to write all 5 of them. They will not be generated by the compiler because if you define one explicitly this probably means that the default compiler-generated implementation is not good for any of them. For example an object containing a raw owning pointer needs to be deleted, but also when you make a copy of it you want to copy the pointed object, not the pointer, in order to preserve value semantics. If you were to copy only the pointer then the copied object would point to the same thing as the original object, they would not be independent copies. Also when the first one would be deleted it would delete the pointer that the other object also uses, and you will get a segmentation fault somewhere because the second object is still alive but its pointer isn't anymore. If you have to implement special member functions explicitly, try to make the class as small as possible. You most likely have only one member of your class that requires the destructor / copy. Then, move that member into its own class that implements the rule of 5, and in your main class use that wrapper class and let the compiler generate the destructor / move / copy. It will prevent you from forgetting to copy a member in your copy / move, or something silly of that kind. tip Most classes shouldn't have explicit special member functions, and those wo do should be kept to a minimal size. (This is known as the Rule of 0)","keywords":""},{"title":"Scope guard","type":0,"sectionRef":"#","url":"lessons/scope-guard","content":"Scope guard Conference","keywords":""},{"title":"Range-based for loop","type":0,"sectionRef":"#","url":"lessons/range-based-for-loop","content":"Range-based for loop It helps you express your intent more clearly. If you want to go over each element once (which the case of most for loops) you can write : const std::vector v = {3, 1, 17, 8}; for (auto x : v) { // do something with x } for (const auto&amp; x : v) { // do something with x } for (auto&amp; x : v) { // do something with x } Copy It guarantees that you are not modifying the index in the body of the loop to make nasty things and change the iteration process.Having this guarantee helps people reason about your code, and this is very important ! const std::vector v = {3, 1, 17, 8}; for (size_t i = 0; i &lt; v.size(); ++i) { // Long body // Might do i++ somewhere } Copy","keywords":""},{"title":"Smart Pointers","type":0,"sectionRef":"#","url":"lessons/smart-pointers","content":"Smart Pointers No naked new : this doesn't mean no dynamic allocations, it just means they should always be done through a smart pointer or a container. #include &lt;memory&gt; MyClass* x = new MyClass(); // BAD std::unique_ptr&lt;MyClass&gt; x = std::make_unique&lt;MyClass&gt;(); // GOOD std::shared_ptr&lt;MyClass&gt; x = std::make_shared&lt;MyClass&gt;(); // GOOD too, but less often what you need Copy","keywords":""},{"title":"Single Source of Truth","type":0,"sectionRef":"#","url":"lessons/single-source-of-truth","content":"Single Source of Truth The Single Source of Truth principle is very simple : only store an information once ! And it stems from a very simple observation : if you store a value (or information that are deduced from that value) in several places, then they all need to be updated at the same time when you change that value. To do so you can try to write setter functions that will update the data in all the required places, but it is so easy to mess up, especially years in the future when someone else comes along and starts modifiyng the code. Basically it introduces oddities in the code that one must be aware of when working with it. This is why if often leads to bugs at some point ; and it also makes the code harder to reason about and maintain !","keywords":""},{"title":"Split problems in small pieces","type":0,"sectionRef":"#","url":"lessons/split-problems-in-small-pieces","content":"Split problems in small pieces Small classes, small functionshttps://youtu.be/glYq-dvgby4","keywords":""},{"title":"Stack vs Heap","type":0,"sectionRef":"#","url":"lessons/stack-vs-heap","content":"Stack vs Heap Good Reasons to use the heap : varying size (std::vector)very big object (image / mesh etc.)live longer than the current scope (image / mesh etc.) Bad reasons to use the heap : polymorphism (use std::variant instead of pointer to a base type)","keywords":""},{"title":"State and Strategy","type":0,"sectionRef":"#","url":"lessons/state-and-strategy","content":"State and Strategy Difference : State handles the changes itself, it is an implementation of a state machine. For Strategy, the decision of changing the strategy comes from the outside, it doesn't depend on what the current strategy is.","keywords":""},{"title":"Static analysis and Sanitizers","type":0,"sectionRef":"#","url":"lessons/static-analysis-and-sanitizers","content":"Static analysis and Sanitizers There are a lot of bugs and bad coding habits that can be caught by tools. It can really help you a lot to improve the quality of your code! If you use this C++ template project you will get a lot of tools installed out of the box. If not, consider using some VS Code extensions: jbenden.c-cpp-flylint and notskm.clang-tidy ; note that you will also have to install the tools that these extension rely one (CppCheck, clang-tidy and so on). To see these tools in action, check this out.","keywords":""},{"title":"Static site generators","type":0,"sectionRef":"#","url":"lessons/static-site-generators","content":"Static site generators","keywords":""},{"title":"STL algorithms","type":0,"sectionRef":"#","url":"lessons/stl-algorithms","content":"","keywords":""},{"title":"Find & find_if​","type":1,"pageTitle":"STL algorithms","url":"lessons/stl-algorithms#find--find_if","content":""},{"title":"Filter​","type":1,"pageTitle":"STL algorithms","url":"lessons/stl-algorithms#filter","content":""},{"title":"Map​","type":1,"pageTitle":"STL algorithms","url":"lessons/stl-algorithms#map","content":""},{"title":"Reduce​","type":1,"pageTitle":"STL algorithms","url":"lessons/stl-algorithms#reduce","content":""},{"title":"std::string and std::string_view","type":0,"sectionRef":"#","url":"lessons/string-and-string-view","content":"","keywords":""},{"title":"string​","type":1,"pageTitle":"std::string and std::string_view","url":"lessons/string-and-string-view#string","content":""},{"title":"string_view​","type":1,"pageTitle":"std::string and std::string_view","url":"lessons/string-and-string-view#string_view","content":"It is a new type from C++17. It is a non-owning reference to either a const char* or a std::string. It has many advantages: providing the same API as std::string for const char* without having to pay the cost of constructing a std::string, working with const char* and std::string as if they were the same type, etc. Just remember that it is non-owning, like a reference: it is great for passing parameters around, but if you need to store it as a long-lasting variable you probably still need to use a std::string. "},{"title":"Strong Typing","type":0,"sectionRef":"#","url":"lessons/strong-typing","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Strong Typing","url":"lessons/strong-typing#brief","content":"Strong typing is when you create a type just to wrap an int, so that you can give that int a name, invariants, and so on. It helps you express your intent more clearly and makes your APIs harder to misuse. They are amazing and definitely worth the extra little time needed to write them down ; don't be lazy ! "},{"title":"Details​","type":1,"pageTitle":"Strong Typing","url":"lessons/strong-typing#details","content":"Read this great article about strong types. And then look at this great example of using strong types to prevent a nasty bug. Once you are done with these, I want to give an example of my own. Consider a 2D position (a.k.a a point) and a 2D displacement (a.k.a. a vector (although that term is way too overloaded and has sadly become ambiguous)). They can both be represented with two numbers x and y even though they are very different concepts ! The fact that they are different concepts means that we can not do the same operations on them ! Strong typing can protect us from accidently doing that. For example, adding two displacements d1 and d2 makes total sense : it simply yields another displacement that is the same as moving by d1 and then by d2 :  Adding a displacement to a position is perfectly reasonable too : it moves the position :  But adding two positions doesn't make sense at all !!!  Even though it would be easy to add the representation of two positions, we want to prevent that because it would most likely be a bug or a logic error. Recap Strong typing helps us give a more concrete representation to concepts, physical units, coordinate spaces, and much more ! They prevent logic errors and make APIs clearer. Going further Strong types for physical units Abstract Algebra and Strong Types "},{"title":"Testing","type":0,"sectionRef":"#","url":"lessons/testing","content":"","keywords":""},{"title":"Unit Tests​","type":1,"pageTitle":"Testing","url":"lessons/testing#unit-tests","content":"For example I wrote tests for the code that computes your grades: TODO PUT A LINK "},{"title":"UnitTesting libraries​","type":1,"pageTitle":"Testing","url":"lessons/testing#unittesting-libraries","content":"There a few out there. I personaly use and recommend doctest. "},{"title":"Going further​","type":1,"pageTitle":"Testing","url":"lessons/testing#going-further","content":"Going further Phil Nash, Test Driven C++ (1h) About TDD "},{"title":"Trailing return type","type":0,"sectionRef":"#","url":"lessons/trailing-return-type","content":"Trailing return type","keywords":""},{"title":"Type design","type":0,"sectionRef":"#","url":"lessons/type-design","content":"Type design About types to model a concept","keywords":""},{"title":"Type erasure","type":0,"sectionRef":"#","url":"lessons/type-erasure","content":"Type erasure https://youtu.be/jKt6A3wnDyI","keywords":""},{"title":"Use libraries","type":0,"sectionRef":"#","url":"lessons/use-libraries","content":"","keywords":""},{"title":"Build from source​","type":1,"pageTitle":"Use libraries","url":"lessons/use-libraries#build-from-source","content":"Building from source means that: anyone simply has to clone your project and is guaranteed to have all the dependenciesyou never have any version conflictyou can tweak the libraries if you need to (and if their license allows so)you have quick access to the source code to read it and your IDE can jump to it To add a library to your project you can simply download the folder and copy it into your project, but a better practice is to use a Git submodule. "},{"title":"Add them to your project with CMake​","type":1,"pageTitle":"Use libraries","url":"lessons/use-libraries#add-them-to-your-project-with-cmake","content":"If the library provides good CMake support, all you should have to do is: add_subdirectory(libname) target_link_libraries(${PROJECT_NAME} PRIVATE libname) Copy If not, then you will have to define the target and its requirements yourself. For that, check out the lesson on CMake for library authors. "},{"title":"Read the documentation​","type":1,"pageTitle":"Use libraries","url":"lessons/use-libraries#read-the-documentation","content":"Read the doc! Really! Or at least all the tutorial and introduction parts! Whenever I finally take the time to sit down and go through the documentation of a library I use, I always end up cursing myself for not doing it earlier because I learn so much while reading it and I realize it would have saved me a lot of debugging time if I had read it before trying to blindly use the library! Plus you will discover amazing features that you were not even aware of! tip Take the time and Read the Fucking Manual. Programing is a slow and patient process. You will save time later down the road if you take the time to do things properly from the get go.  "},{"title":"std::variant","type":0,"sectionRef":"#","url":"lessons/variant","content":"std::variant https://youtu.be/ojZbFIQSdl8?t=869https://youtu.be/ojZbFIQSdl8?t=1128 It is a very good alternative to enums, because it can contain data, and be resolved through functions overload instead of switches. To replace polymorphism made with inheritance: https://youtu.be/gKbORJtnVu8","keywords":""},{"title":"std::vector","type":0,"sectionRef":"#","url":"lessons/vector","content":"std::vector Despite its awfull name, this is the most amazing container ever !","keywords":""},{"title":"wasm and electron","type":0,"sectionRef":"#","url":"lessons/wasm-and-electron","content":"wasm and electron","keywords":""},{"title":"Write libraries","type":0,"sectionRef":"#","url":"lessons/write-libraries","content":"Write libraries Even if it's only for your personal use, it will help you a lot with code reuse across projects and also inside one project. And also it will force you to make your code a little more generic, which most of the time will improve it at the same time. Moreover, it will make sure that the code is decoupled from the rest of your application. So : as soon as you are write some bit of code that is fairly generic, consider turning it into a library. For CMake refer back to here.","keywords":""},{"title":"Watch conferences","type":0,"sectionRef":"#","url":"lessons/watch-conferences","content":"Watch conferences This is the best away to improve once you have acquired a solid basis through classes and projects.","keywords":""},{"title":"Write small functions","type":0,"sectionRef":"#","url":"lessons/write-small-functions","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Write small functions","url":"lessons/write-small-functions#brief","content":"Small functions are way easier to read and reason about. Here is what the Core Guidelines have to say about it : https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-single "},{"title":"Details​","type":1,"pageTitle":"Write small functions","url":"lessons/write-small-functions#details","content":"I used to write long functions like this, using comments to indicate the different parts of the function, because it felt silly to me to create a function that I would only use in one place. void View::imgui_window(ImTextureID image_texture_id, ImageSize image_size, bool need_to_fit) { if (_is_open) { ImGui::Begin(_name.c_str(), &amp;_is_open, ImGuiWindowFlags_NoScrollbar); // Update _size auto size = ImGui::GetContentRegionAvail(); if (size.x &gt;= 1.f &amp;&amp; size.y &gt;= 1.f) { _size.emplace( static_cast&lt;ImageSize::DataType&gt;(size.x), static_cast&lt;ImageSize::DataType&gt;(size.y)); } else { _size.reset(); } // Update _position _position = ImGui::GetCursorScreenPos(); if (_size.has_value()) { // Display the image const auto fitted_image_size = need_to_fit ? ImageSizeU::fit_into(*_size, image_size) : static_cast&lt;ImageSizeT&lt;float&gt;&gt;(*_size); ImGuiExtras::image_centered(image_texture_id, {fitted_image_size.width(), fitted_image_size.height()}); _is_hovered = ImGui::IsItemHovered(); } else { _is_hovered = false; } ImGui::End(); } else { _size.reset(); _is_hovered = false; } } Copy But I had to admit that I was having trouble reading those long functions, and that maybe everyone else was right. The same code as above would look like this once split into more atomic parts : void View::imgui_window(ImTextureID image_texture_id, ImageSize image_size, bool need_to_fit) { if (_is_open) { ImGui::Begin(_name.c_str(), &amp;_is_open, ImGuiWindowFlags_NoScrollbar); grab_window_size(); grab_window_position(); display_image(image_texture_id, image_size, need_to_fit); ImGui::End(); } else { _size.reset(); _is_hovered = false; } } void View::grab_window_size() { auto size = ImGui::GetContentRegionAvail(); if (size.x &gt;= 1.f &amp;&amp; size.y &gt;= 1.f) { _size.emplace( static_cast&lt;ImageSize::DataType&gt;(size.x), static_cast&lt;ImageSize::DataType&gt;(size.y)); } else { _size.reset(); } } void View::grab_window_position() { _position = ImGui::GetCursorScreenPos(); } void View::display_image(ImTextureID image_texture_id, ImageSize image_size, bool need_to_fit) { if (_size.has_value()) { const auto fitted_image_size = need_to_fit ? ImageSizeU::fit_into(*_size, image_size) : static_cast&lt;ImageSizeT&lt;float&gt;&gt;(*_size); ImGuiExtras::image_centered(image_texture_id, {fitted_image_size.width(), fitted_image_size.height()}); _is_hovered = ImGui::IsItemHovered(); } else { _is_hovered = false; } } Copy "},{"title":"Introduction","type":0,"sectionRef":"#","url":"progress","content":"","keywords":""},{"title":"How are the lessons sorted?​","type":1,"pageTitle":"Introduction","url":"progress#how-are-the-lessons-sorted","content":"They are first sorted by Order, which is a rough measure of a logical order that the lessons should be learned in. For example you can't learn about Git submodules if you don't even know what Git is yet. Then, for lessons of the same Order, a Priority is computed as 0.75 * Benefit + 0.25 * Easiness, which is then remapped between 100% and 0% according to the Order. Benefit measures how much your code or workflow will improve if you learn that lesson, and Easiness measures how easy it will be to learn that lessons. The bests lessons are the ones that have a huge impact and are easy to learn, and this is the ones that will have the highest Priorities. "},{"title":"How is my grade calculated?​","type":1,"pageTitle":"Introduction","url":"progress#how-is-my-grade-calculated","content":"Each mastered lesson gives you some points based on how long it should have taken you to learn. We sum all those points, and then apply a compression function to map this score between 0 and 20. You can see the exact source code that we use here. "},{"title":"Self-evaluation​","type":1,"pageTitle":"Introduction","url":"progress#self-evaluation","content":"Please tick the lessons that you consider to master already, then export them as json using that big green button and send them to me. If you have a doubt, don't tick the checkbox; in the worst case this will mean that you will have a lesson that is easy to validate during the semester. You don't need to check lessons of order 3 or higher if you can't be bothered reading the whole list (which is arguably pretty long). Filters: Select All Remove All Clean Code Tools C++ Workflow Git Libraries &amp; Frameworks Beautiful Code Performant Code Export as JSON Lesson\tValidated\tTags\tPriority\tBenefit\tEasiness\tOrder Use an IDE Tools 100 %\t5\t5\t1 Use Git Tools Git 99 %\t5\t4\t1 Use a debugger Tools 99 %\t5\t4\t1 Use a formatting tool Tools 96 %\t4\t5\t1 Naming Clean Code 95 %\t5\t1\t1 Consistency in style Beautiful Code 89 %\t2\t5\t1 Prefer free functions Clean Code 78 %\t5\t3\t2 Design Great Classes Clean Code 78 %\t5\t3\t2 Write small functions Clean Code 78 %\t5\t3\t2 Make it work, then make it good Workflow 78 %\t5\t3\t2 DRY: Don't repeat yourself Clean Code 76 %\t5\t2\t2 Orthogonality Clean Code 76 %\t5\t2\t2 Split problems in small pieces Workflow 75 %\t5\t1\t2 std::vector Clean Code Performant Code C++ 60 %\t5\t5\t3 Documentation Clean Code 57 %\t5\t3\t3 Stack vs Heap Performant Code 57 %\t5\t3\t3 Static analysis and Sanitizers Tools 57 %\t5\t3\t3 Use libraries Clean Code 57 %\t5\t3\t3 assert Clean Code 56 %\t4\t5\t3 auto Beautiful Code Clean Code C++ 56 %\t4\t5\t3 Enums Clean Code C++ 56 %\t4\t5\t3 Testing Clean Code 56 %\t5\t2\t3 Type design Clean Code 56 %\t5\t2\t3 Dependencies Clean Code 55 %\t5\t1\t3 Lambda functions Clean Code C++ 55 %\t4\t4\t3 Master your IDE Tools 55 %\t4\t4\t3 std::optional Clean Code C++ 55 %\t4\t4\t3 Single Source of Truth Clean Code 55 %\t4\t4\t3 Strong Typing Clean Code 55 %\t4\t4\t3 Code reviews Workflow 54 %\t4\t3\t3 const Clean Code C++ 54 %\t4\t3\t3 Don't overfocus on performance Clean Code 54 %\t4\t3\t3 Git submodules Tools Git 54 %\t4\t3\t3 STL algorithms Clean Code Performant Code C++ 54 %\t4\t3\t3 Composition over Inheritance Clean Code 53 %\t4\t2\t3 Debug vs Release Clean Code 53 %\t3\t5\t3 Immediately Invoked Function Clean Code 53 %\t3\t5\t3 Markdown Tools 53 %\t3\t5\t3 Range-based for loop Clean Code C++ 53 %\t3\t5\t3 Smart Pointers Clean Code C++ 53 %\t3\t5\t3 Error Handling Clean Code 51 %\t3\t4\t3 Git Pull Requests Tools Git 51 %\t3\t4\t3 Advanced Git features Tools Git 50 %\t3\t3\t3 CMake C++ 50 %\t3\t3\t3 Functional programming Clean Code 50 %\t3\t3\t3 Move semantics Performant Code C++ 50 %\t3\t3\t3 The Rule of 5 Clean Code C++ 50 %\t3\t3\t3 State and Strategy Clean Code 50 %\t3\t3\t3 std::variant Clean Code Performant Code C++ 50 %\t3\t3\t3 Cache and Branches Performant Code 49 %\t3\t2\t3 Multithreading Performant Code 49 %\t3\t2\t3 Polymorphism Clean Code 49 %\t3\t2\t3 Watch conferences Workflow 38 %\t5\t3\t4 Write libraries Clean Code 38 %\t5\t3\t4 Dear ImGui Libraries &amp; Frameworks 36 %\t5\t2\t4 Designated Initializers Clean Code C++ 36 %\t4\t5\t4 std::string and std::string_view C++ 35 %\t4\t4\t4 Static site generators Tools 34 %\t4\t3\t4 Deleted functions Clean Code C++ 33 %\t3\t5\t4 Type erasure Clean Code 33 %\t4\t2\t4 wasm and electron Libraries &amp; Frameworks 33 %\t4\t2\t4 Scope guard Clean Code 31 %\t3\t4\t4 C++ casts Clean Code C++ 30 %\t3\t3\t4 Measuring performance Performant Code 30 %\t3\t3\t4 Precompiled Header C++ 30 %\t3\t3\t4 &lt;random&gt; C++ 30 %\t3\t3\t4 Linked lists Performant Code 29 %\t2\t5\t4 Avoid dead code Clean Code 26 %\t2\t3\t4 friend Clean Code C++ 25 %\t1\t5\t4 Pointers vs References Clean Code C++ 25 %\t2\t2\t4 Avoid nested namespaces Clean Code C++ 5 %\t1\t5\t5 #if defined() Beautiful Code C++ 5 %\t1\t5\t5 Trailing return type Beautiful Code C++ 5 %\t1\t5\t5 Order: 1: the basic tools that you must use while you write code, and the basic habits that you must start to try picking up2: the essential principles that will naturally lead you to writing better code.3: many things that will improve your code: C++ features, design patterns, implmeentation tricks, more tools etc.4: Nice to have features, or things to do when you are grown up and understand most of the things of order 35: When you have nothing important to learn anymore "},{"title":"Hortense H","type":0,"sectionRef":"#","url":"progress/hortense_h","content":"Hortense H Filters: Select All Remove All Clean Code Tools C++ Workflow Git Libraries &amp; Frameworks Beautiful Code Performant Code 11.3 / 20 11.3 / 20 Lesson\tValidated\tTags\tPriority\tBenefit\tEasiness\tOrder Use an IDE Tools 100 %\t5\t5\t1 Use Git Tools Git 99 %\t5\t4\t1 Use a debugger Tools 99 %\t5\t4\t1 Use a formatting tool Tools 96 %\t4\t5\t1 Naming Clean Code 95 %\t5\t1\t1 Consistency in style Beautiful Code 89 %\t2\t5\t1 Prefer free functions Clean Code 78 %\t5\t3\t2 Design Great Classes Clean Code 78 %\t5\t3\t2 Write small functions Clean Code 78 %\t5\t3\t2 Make it work, then make it good Workflow 78 %\t5\t3\t2 DRY: Don't repeat yourself Clean Code 76 %\t5\t2\t2 Orthogonality Clean Code 76 %\t5\t2\t2 Split problems in small pieces Workflow 75 %\t5\t1\t2 std::vector Clean Code Performant Code C++ 60 %\t5\t5\t3 Documentation Clean Code 57 %\t5\t3\t3 Stack vs Heap Performant Code 57 %\t5\t3\t3 Static analysis and Sanitizers Tools 57 %\t5\t3\t3 Use libraries Clean Code 57 %\t5\t3\t3 assert Clean Code 56 %\t4\t5\t3 auto Beautiful Code Clean Code C++ 56 %\t4\t5\t3 Enums Clean Code C++ 56 %\t4\t5\t3 Testing Clean Code 56 %\t5\t2\t3 Type design Clean Code 56 %\t5\t2\t3 Dependencies Clean Code 55 %\t5\t1\t3 Lambda functions Clean Code C++ 55 %\t4\t4\t3 Master your IDE Tools 55 %\t4\t4\t3 std::optional Clean Code C++ 55 %\t4\t4\t3 Single Source of Truth Clean Code 55 %\t4\t4\t3 Strong Typing Clean Code 55 %\t4\t4\t3 Code reviews Workflow 54 %\t4\t3\t3 const Clean Code C++ 54 %\t4\t3\t3 Don't overfocus on performance Clean Code 54 %\t4\t3\t3 Git submodules Tools Git 54 %\t4\t3\t3 STL algorithms Clean Code Performant Code C++ 54 %\t4\t3\t3 Composition over Inheritance Clean Code 53 %\t4\t2\t3 Debug vs Release Clean Code 53 %\t3\t5\t3 Immediately Invoked Function Clean Code 53 %\t3\t5\t3 Markdown Tools 53 %\t3\t5\t3 Range-based for loop Clean Code C++ 53 %\t3\t5\t3 Smart Pointers Clean Code C++ 53 %\t3\t5\t3 Error Handling Clean Code 51 %\t3\t4\t3 Git Pull Requests Tools Git 51 %\t3\t4\t3 Advanced Git features Tools Git 50 %\t3\t3\t3 CMake C++ 50 %\t3\t3\t3 Functional programming Clean Code 50 %\t3\t3\t3 Move semantics Performant Code C++ 50 %\t3\t3\t3 The Rule of 5 Clean Code C++ 50 %\t3\t3\t3 State and Strategy Clean Code 50 %\t3\t3\t3 std::variant Clean Code Performant Code C++ 50 %\t3\t3\t3 Cache and Branches Performant Code 49 %\t3\t2\t3 Multithreading Performant Code 49 %\t3\t2\t3 Polymorphism Clean Code 49 %\t3\t2\t3 Watch conferences Workflow 38 %\t5\t3\t4 Write libraries Clean Code 38 %\t5\t3\t4 Dear ImGui Libraries &amp; Frameworks 36 %\t5\t2\t4 Designated Initializers Clean Code C++ 36 %\t4\t5\t4 std::string and std::string_view C++ 35 %\t4\t4\t4 Static site generators Tools 34 %\t4\t3\t4 Deleted functions Clean Code C++ 33 %\t3\t5\t4 Type erasure Clean Code 33 %\t4\t2\t4 wasm and electron Libraries &amp; Frameworks 33 %\t4\t2\t4 Scope guard Clean Code 31 %\t3\t4\t4 C++ casts Clean Code C++ 30 %\t3\t3\t4 Measuring performance Performant Code 30 %\t3\t3\t4 Precompiled Header C++ 30 %\t3\t3\t4 &lt;random&gt; C++ 30 %\t3\t3\t4 Linked lists Performant Code 29 %\t2\t5\t4 Avoid dead code Clean Code 26 %\t2\t3\t4 friend Clean Code C++ 25 %\t1\t5\t4 Pointers vs References Clean Code C++ 25 %\t2\t2\t4 Avoid nested namespaces Clean Code C++ 5 %\t1\t5\t5 #if defined() Beautiful Code C++ 5 %\t1\t5\t5 Trailing return type Beautiful Code C++ 5 %\t1\t5\t5","keywords":""},{"title":"Jean-Michel P","type":0,"sectionRef":"#","url":"progress/jean-michel_p","content":"Jean-Michel P Filters: Select All Remove All Clean Code Tools C++ Workflow Git Libraries &amp; Frameworks Beautiful Code Performant Code 3.8 / 20 3.8 / 20 Lesson\tValidated\tTags\tPriority\tBenefit\tEasiness\tOrder Use an IDE Tools 100 %\t5\t5\t1 Use Git Tools Git 99 %\t5\t4\t1 Use a debugger Tools 99 %\t5\t4\t1 Use a formatting tool Tools 96 %\t4\t5\t1 Naming Clean Code 95 %\t5\t1\t1 Consistency in style Beautiful Code 89 %\t2\t5\t1 Prefer free functions Clean Code 78 %\t5\t3\t2 Design Great Classes Clean Code 78 %\t5\t3\t2 Write small functions Clean Code 78 %\t5\t3\t2 Make it work, then make it good Workflow 78 %\t5\t3\t2 DRY: Don't repeat yourself Clean Code 76 %\t5\t2\t2 Orthogonality Clean Code 76 %\t5\t2\t2 Split problems in small pieces Workflow 75 %\t5\t1\t2 std::vector Clean Code Performant Code C++ 60 %\t5\t5\t3 Documentation Clean Code 57 %\t5\t3\t3 Stack vs Heap Performant Code 57 %\t5\t3\t3 Static analysis and Sanitizers Tools 57 %\t5\t3\t3 Use libraries Clean Code 57 %\t5\t3\t3 assert Clean Code 56 %\t4\t5\t3 auto Beautiful Code Clean Code C++ 56 %\t4\t5\t3 Enums Clean Code C++ 56 %\t4\t5\t3 Testing Clean Code 56 %\t5\t2\t3 Type design Clean Code 56 %\t5\t2\t3 Dependencies Clean Code 55 %\t5\t1\t3 Lambda functions Clean Code C++ 55 %\t4\t4\t3 Master your IDE Tools 55 %\t4\t4\t3 std::optional Clean Code C++ 55 %\t4\t4\t3 Single Source of Truth Clean Code 55 %\t4\t4\t3 Strong Typing Clean Code 55 %\t4\t4\t3 Code reviews Workflow 54 %\t4\t3\t3 const Clean Code C++ 54 %\t4\t3\t3 Don't overfocus on performance Clean Code 54 %\t4\t3\t3 Git submodules Tools Git 54 %\t4\t3\t3 STL algorithms Clean Code Performant Code C++ 54 %\t4\t3\t3 Composition over Inheritance Clean Code 53 %\t4\t2\t3 Debug vs Release Clean Code 53 %\t3\t5\t3 Immediately Invoked Function Clean Code 53 %\t3\t5\t3 Markdown Tools 53 %\t3\t5\t3 Range-based for loop Clean Code C++ 53 %\t3\t5\t3 Smart Pointers Clean Code C++ 53 %\t3\t5\t3 Error Handling Clean Code 51 %\t3\t4\t3 Git Pull Requests Tools Git 51 %\t3\t4\t3 Advanced Git features Tools Git 50 %\t3\t3\t3 CMake C++ 50 %\t3\t3\t3 Functional programming Clean Code 50 %\t3\t3\t3 Move semantics Performant Code C++ 50 %\t3\t3\t3 The Rule of 5 Clean Code C++ 50 %\t3\t3\t3 State and Strategy Clean Code 50 %\t3\t3\t3 std::variant Clean Code Performant Code C++ 50 %\t3\t3\t3 Cache and Branches Performant Code 49 %\t3\t2\t3 Multithreading Performant Code 49 %\t3\t2\t3 Polymorphism Clean Code 49 %\t3\t2\t3 Watch conferences Workflow 38 %\t5\t3\t4 Write libraries Clean Code 38 %\t5\t3\t4 Dear ImGui Libraries &amp; Frameworks 36 %\t5\t2\t4 Designated Initializers Clean Code C++ 36 %\t4\t5\t4 std::string and std::string_view C++ 35 %\t4\t4\t4 Static site generators Tools 34 %\t4\t3\t4 Deleted functions Clean Code C++ 33 %\t3\t5\t4 Type erasure Clean Code 33 %\t4\t2\t4 wasm and electron Libraries &amp; Frameworks 33 %\t4\t2\t4 Scope guard Clean Code 31 %\t3\t4\t4 C++ casts Clean Code C++ 30 %\t3\t3\t4 Measuring performance Performant Code 30 %\t3\t3\t4 Precompiled Header C++ 30 %\t3\t3\t4 &lt;random&gt; C++ 30 %\t3\t3\t4 Linked lists Performant Code 29 %\t2\t5\t4 Avoid dead code Clean Code 26 %\t2\t3\t4 friend Clean Code C++ 25 %\t1\t5\t4 Pointers vs References Clean Code C++ 25 %\t2\t2\t4 Avoid nested namespaces Clean Code C++ 5 %\t1\t5\t5 #if defined() Beautiful Code C++ 5 %\t1\t5\t5 Trailing return type Beautiful Code C++ 5 %\t1\t5\t5","keywords":""},{"title":"Jules F","type":0,"sectionRef":"#","url":"progress/jules_f","content":"Jules F Filters: Select All Remove All Clean Code Tools C++ Workflow Git Libraries &amp; Frameworks Beautiful Code Performant Code 17.3 / 20 17.3 / 20 Lesson\tValidated\tTags\tPriority\tBenefit\tEasiness\tOrder Use an IDE Tools 100 %\t5\t5\t1 Use Git Tools Git 99 %\t5\t4\t1 Use a debugger Tools 99 %\t5\t4\t1 Use a formatting tool Tools 96 %\t4\t5\t1 Naming Clean Code 95 %\t5\t1\t1 Consistency in style Beautiful Code 89 %\t2\t5\t1 Prefer free functions Clean Code 78 %\t5\t3\t2 Design Great Classes Clean Code 78 %\t5\t3\t2 Write small functions Clean Code 78 %\t5\t3\t2 Make it work, then make it good Workflow 78 %\t5\t3\t2 DRY: Don't repeat yourself Clean Code 76 %\t5\t2\t2 Orthogonality Clean Code 76 %\t5\t2\t2 Split problems in small pieces Workflow 75 %\t5\t1\t2 std::vector Clean Code Performant Code C++ 60 %\t5\t5\t3 Documentation Clean Code 57 %\t5\t3\t3 Stack vs Heap Performant Code 57 %\t5\t3\t3 Static analysis and Sanitizers Tools 57 %\t5\t3\t3 Use libraries Clean Code 57 %\t5\t3\t3 assert Clean Code 56 %\t4\t5\t3 auto Beautiful Code Clean Code C++ 56 %\t4\t5\t3 Enums Clean Code C++ 56 %\t4\t5\t3 Testing Clean Code 56 %\t5\t2\t3 Type design Clean Code 56 %\t5\t2\t3 Dependencies Clean Code 55 %\t5\t1\t3 Lambda functions Clean Code C++ 55 %\t4\t4\t3 Master your IDE Tools 55 %\t4\t4\t3 std::optional Clean Code C++ 55 %\t4\t4\t3 Single Source of Truth Clean Code 55 %\t4\t4\t3 Strong Typing Clean Code 55 %\t4\t4\t3 Code reviews Workflow 54 %\t4\t3\t3 const Clean Code C++ 54 %\t4\t3\t3 Don't overfocus on performance Clean Code 54 %\t4\t3\t3 Git submodules Tools Git 54 %\t4\t3\t3 STL algorithms Clean Code Performant Code C++ 54 %\t4\t3\t3 Composition over Inheritance Clean Code 53 %\t4\t2\t3 Debug vs Release Clean Code 53 %\t3\t5\t3 Immediately Invoked Function Clean Code 53 %\t3\t5\t3 Markdown Tools 53 %\t3\t5\t3 Range-based for loop Clean Code C++ 53 %\t3\t5\t3 Smart Pointers Clean Code C++ 53 %\t3\t5\t3 Error Handling Clean Code 51 %\t3\t4\t3 Git Pull Requests Tools Git 51 %\t3\t4\t3 Advanced Git features Tools Git 50 %\t3\t3\t3 CMake C++ 50 %\t3\t3\t3 Functional programming Clean Code 50 %\t3\t3\t3 Move semantics Performant Code C++ 50 %\t3\t3\t3 The Rule of 5 Clean Code C++ 50 %\t3\t3\t3 State and Strategy Clean Code 50 %\t3\t3\t3 std::variant Clean Code Performant Code C++ 50 %\t3\t3\t3 Cache and Branches Performant Code 49 %\t3\t2\t3 Multithreading Performant Code 49 %\t3\t2\t3 Polymorphism Clean Code 49 %\t3\t2\t3 Watch conferences Workflow 38 %\t5\t3\t4 Write libraries Clean Code 38 %\t5\t3\t4 Dear ImGui Libraries &amp; Frameworks 36 %\t5\t2\t4 Designated Initializers Clean Code C++ 36 %\t4\t5\t4 std::string and std::string_view C++ 35 %\t4\t4\t4 Static site generators Tools 34 %\t4\t3\t4 Deleted functions Clean Code C++ 33 %\t3\t5\t4 Type erasure Clean Code 33 %\t4\t2\t4 wasm and electron Libraries &amp; Frameworks 33 %\t4\t2\t4 Scope guard Clean Code 31 %\t3\t4\t4 C++ casts Clean Code C++ 30 %\t3\t3\t4 Measuring performance Performant Code 30 %\t3\t3\t4 Precompiled Header C++ 30 %\t3\t3\t4 &lt;random&gt; C++ 30 %\t3\t3\t4 Linked lists Performant Code 29 %\t2\t5\t4 Avoid dead code Clean Code 26 %\t2\t3\t4 friend Clean Code C++ 25 %\t1\t5\t4 Pointers vs References Clean Code C++ 25 %\t2\t2\t4 Avoid nested namespaces Clean Code C++ 5 %\t1\t5\t5 #if defined() Beautiful Code C++ 5 %\t1\t5\t5 Trailing return type Beautiful Code C++ 5 %\t1\t5\t5","keywords":""}]