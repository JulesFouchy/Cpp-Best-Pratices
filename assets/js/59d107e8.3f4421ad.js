"use strict";(self.webpackChunkteaching_toolbox_website_generator=self.webpackChunkteaching_toolbox_website_generator||[]).push([[7470],{8173:function(e){e.exports=JSON.parse('{"name":"C++","permalink":"/Learn--Cpp-And-Dev-Practices/tags/c","docs":[{"id":"lessons/if-defined","title":"#if defined()","description":"#if defined(SOMETHING) offers more flexibility than #ifdef SOMETHING.","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/if-defined"},{"id":"lessons/auto","title":"auto","description":"Most of the time the type of a variable is obvious and a type declaration would be redundant. In such cases you can use auto instead :","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/auto"},{"id":"lessons/against-nested-namespaces","title":"Avoid nested namespaces","description":"https://youtu.be/xu7q8dGvuwk?t=1198","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/against-nested-namespaces"},{"id":"lessons/cpp-casts","title":"C++ casts","description":"5 min","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/cpp-casts"},{"id":"lessons/cmake","title":"CMake","description":"Brief","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/cmake"},{"id":"lessons/const","title":"const","description":"Bonus trick","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/const"},{"id":"lessons/deleted-functions","title":"Deleted functions","description":"You can delete functions to prevent them from beeing used. This is mostly used to prevent a type from being copied ; for example std::sharedptr.","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/deleted-functions"},{"id":"lessons/designated_initializers","title":"Designated Initializers","description":"https://youtu.be/nm45t2fnUms","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/designated_initializers"},{"id":"lessons/enums","title":"Enums","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/enums"},{"id":"lessons/friend","title":"friend","description":"There are *very few* good reasons to use `friend`.","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/friend"},{"id":"lessons/lambda","title":"Lambda functions","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/lambda"},{"id":"lessons/move-semantics","title":"Move semantics","description":"Brief","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/move-semantics"},{"id":"lessons/pointer-vs-reference","title":"Pointers vs References","description":"Pointers can be null","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/pointer-vs-reference"},{"id":"lessons/precompiled-header","title":"Precompiled Header","description":"https://youtu.be/eSI4wctZUto","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/precompiled-header"},{"id":"lessons/random","title":"Random","description":"Stephan T. Lavavej, rand() Considered Harmful (30min)","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/random"},{"id":"lessons/range-based-for-loop","title":"Range-based for loop","description":"It helps you express your intent more clearly. If you want to go over each element once (which the case of most for loops) you can write :","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/range-based-for-loop"},{"id":"lessons/smart-pointers","title":"Smart Pointers","description":"No naked new : this doesn\'t mean no dynamic allocations, it just means they should always be done through a smart pointer or a container.","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/smart-pointers"},{"id":"lessons/optional","title":"std::optional","description":"https://youtu.be/ojZbFIQSdl8?t=1056","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/optional"},{"id":"lessons/variant","title":"std::variant","description":"https://youtu.be/ojZbFIQSdl8?t=869","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/variant"},{"id":"lessons/vector","title":"std::vector","description":"Despite its awfull name, this is the most amazing container ever !","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/vector"},{"id":"lessons/stl-algorithms","title":"STL algorithms","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/stl-algorithms"},{"id":"lessons/string-and-string-view","title":"string and string_view","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/string-and-string-view"},{"id":"lessons/rule-of-5","title":"The Rule of 5","description":"The Rule of 5 states that if you write a special member function (a.k.a. a destructor, a copy constructor, a copy assignment, a move constructor or a move assignment), then you need to write all 5 of them. They will not be generated by the compiler because if you define one explicitly this probably means that the default compiler-generated implementation is not good for any of them.","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/rule-of-5"},{"id":"lessons/trailing-return-type","title":"Trailing return type","description":"","permalink":"/Learn--Cpp-And-Dev-Practices/lessons/trailing-return-type"}],"allTagsPath":"/Learn--Cpp-And-Dev-Practices/tags"}')}}]);